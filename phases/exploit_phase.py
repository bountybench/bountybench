import os
from agents.base_agent import AgentConfig, BaseAgent
from messages.phase_messages.phase_message import PhaseMessage
from phases.base_phase import BasePhase
from agents.executor_agent.executor_agent import ExecutorAgent
from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from resources.base_resource import BaseResource
from resources.init_files_resource import InitFilesResource, InitFilesResourceConfig
from resources.model_resource.model_resource import ModelResource, ModelResourceConfig
from resources.utils import contains_setup
from messages.message import Message
from resources.kali_env_resource import KaliEnvResource, KaliEnvResourceConfig
from resources.docker_resource import DockerResource, DockerResourceConfig
from resources.resource_enum import Resource
from typing import Any, Dict, Optional, Tuple, Type
from resources.setup_resource import SetupResource, SetupResourceConfig
from utils.logger import get_main_logger
from workflows.base_workflow import BaseWorkflow
from resources.memory_resource import MemoryResource, MemoryResourceConfig


logger = get_main_logger(__name__)

class ExploitPhase(BasePhase):
    AGENT_CLASSES = [ExecutorAgent, ExploitAgent]

    def __init__(self, workflow: 'BaseWorkflow', **kwargs):
        self.model = kwargs.get('model')
        self.helm = kwargs.get('helm')
        self.bounty_number = kwargs.get('bounty_number')
        self._initial_prompt = kwargs.get('initial_prompt')
        self.bounty_dir = os.path.join("bounties", f"bounty_{self.bounty_number}")

        super().__init__(workflow, **kwargs)

    def define_agents(self) -> Dict[str, Tuple[Type[BaseAgent], Optional[AgentConfig]]]:
        # Create the executor_config
        executor_config = AgentConfig()

        exploit_config = ExploitAgentConfig(
            bounty_dir=self.bounty_dir,
            task_dir=self.workflow.task_dir
        )

        return {"executor_agent": (ExecutorAgent, executor_config),
                "exploit_agent": (ExploitAgent, exploit_config)
        }
    
    def define_default_resources(self) -> Dict[str, Tuple[Type['BaseResource'], Any]]:
        """
        Define resource classes and their configurations required by the ExploitPhase.

        Returns:
            Dict[str, Tuple[Type[BaseResource], Any]]: Mapping of resource_id to (ResourceClass, ResourceConfig).
        """
        logger.debug(f"Entering define_resources for ExploitPhase")

        files_dir_name = self.workflow.bounty_metadata.get('files_dir', 'codebase')
        vulnerable_commit = self.workflow.bounty_metadata.get('vulnerable_commit', 'main')
        tmp_dir_name = "tmp"
        tmp_dir = os.path.join(self.workflow.task_dir, tmp_dir_name)

        default_resources = [
            (
                Resource.MODEL,
                ModelResourceConfig.create(model=self.model)),
            (
                Resource.INIT_FILES,
                InitFilesResourceConfig(
                    task_dir=self.workflow.task_dir,
                    files_dir_name=files_dir_name,
                    tmp_dir_name=tmp_dir_name,
                    bounty_number=self.bounty_number,
                    vulnerable_commit=vulnerable_commit
                ),
            ),
            (
                Resource.KALI_ENV,
                KaliEnvResourceConfig(
                    task_dir=self.workflow.task_dir,
                    bounty_number=self.workflow.bounty_number,
                    volumes={
                        os.path.abspath(tmp_dir): {"bind": "/app", "mode": "rw"},
                    }, 
                    target_host=self.workflow.repo_metadata["target_host"]
                ),
            ),
            (
                Resource.DOCKER,
                DockerResourceConfig(),
            ),
            (
                Resource.MEMORY,
                MemoryResourceConfig(),
            ),
        ]
        setup_repo_env_script = os.path.join(str(self.workflow.task_dir), "setup_repo_env.sh")
        if contains_setup(setup_repo_env_script):
            default_resources.append(
                (
                    Resource.REPO_RESOURCE,
                    SetupResourceConfig(
                        bounty_level_setup=False,
                        task_dir=self.workflow.task_dir,
                    )
                )
            )

        setup_bounty_env_script = os.path.join(str(self.workflow.task_dir), self.bounty_dir, "setup_files", "setup_bounty_env.sh")
        if contains_setup(setup_bounty_env_script):
            default_resources.append(
                Resource.BOUNTY_RESOURCE,
                SetupResourceConfig(
                    bounty_level_setup=True,
                    task_dir=self.workflow.task_dir,
                    bounty_number=self.workflow.bounty_number,
                )
            )

        logger.debug(f"Exiting define_resources for ExploitPhase")
        return default_resources

    async def run_one_iteration(
        self,
        phase_message: PhaseMessage,
        agent_instance: Any,
        previous_output: Optional[Message]
    ) -> Message:
        """
        1) Call the agent with the previous_message as input (if any).
        2) If ExecutorAgent produces an AnswerMessageInterface, treat as hallucination -> finalize & done.
        3) If ExploitAgent produces AnswerMessageInterface, treat as exploit success -> finalize & done.
        4) Otherwise continue.
        """
        # Prepare input message list for agent
        input_list = []
        if previous_output is not None:
            input_list.append(previous_output)

        message = await agent_instance.run(input_list)

        # Check for exploit success (ExploitAgent)
        if isinstance(agent_instance, ExploitAgent):
            if message.success:
                logger.status("Exploit successful!", True)
                phase_message.set_summary("exploit_success")
                phase_message.set_complete()
                phase_message.set_success()
                return message

        return message
