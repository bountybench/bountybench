import os
from agents.base_agent import AgentConfig
from agents.dataclasses.agent_lm_spec import AgentLMConfig
from phase_messages.phase_message import PhaseMessage
from phases.base_phase import BasePhase
from agents.executor_agent.executor_agent import ExecutorAgent, ExecutorAgentConfig
from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from resources.base_resource import BaseResource
from resources.init_files_resource import InitFilesResource, InitFilesResourceConfig
from messages.answer_message import AnswerMessageInterface
from messages.exploit_message_interface import ExploitMessageInterface
from messages.message import Message
from resources.kali_env_resource import KaliEnvResource, KaliEnvResourceConfig
from resources.docker_resource import DockerResource, DockerResourceConfig
from typing import Any, Dict, List, Optional, Tuple, Type
from resources.setup_resource import SetupResource, SetupResourceConfig
from utils.logger import get_main_logger


logger = get_main_logger(__name__)

class ExploitPhase(BasePhase):
    """
    Phase that cycles through:
      - ExecutorAgent
      - ExploitAgent
    Checks for hallucination (Executor) or exploit success (Exploit) to end early.
    """

    """
    It's fine to have Response objects / should we overload responses, e.g.
        PhaseResponse v AgentResponse and all existing responses are AgentResponses? Or just a new structure
    The issue with just passing AgentResponses is that it fails to encode higher order logic that happens at a phase
    For instance here, success or failure of the exploitphase
        (require)

        Basically we're losing all the Phase level logic, so have a PhaseResponse which may contain one or more AgentResponses and additional Phase level information
    """
    AGENT_CLASSES = [ExecutorAgent, ExploitAgent]

    def define_agents(self) -> List[Tuple[str, AgentConfig]]:
        # there could be a default model e.g. o3, but a workflow should be able to override as needed. Do we want a new exploit phase just to try out claude 3.5 or o1? along with other LM config overrides. It's nice to not [have to], but important to be [able to]
        executor_lm_config = AgentLMConfig(
            model='openai/o3-mini-2024-12-17',
            max_output_tokens=5000,
            max_input_tokens=5000,
            max_iterations_stored_in_memory=3,
            use_helm=False
        )

        # Workflow paradigm, construct an initial PhaseMessage for first Phase (if needed), then continue. Workflow is not passed in, clean separation / dependencies (vs passing in entire workflow, who knows what will be accessed, will be very messy, vs clean Response objects)
        #
        # ExploitPhaseInitMessage <= what is needed? and no Workflow
        # weird circular dependencies, Workflow contains Phases, which contain Workflow?? Workflow ocntain phases which contain agents. Phases are not aware of workflow.
        #  
        # why pass in workflow and call workflow.initial_prompt, versus just pass a prompt in? and rather, shouldn't we just be passing in a PhaseResponse which contains the target host and initial prompt? 
        # I think we should just be passing in a Message object
        # perhaps should rename Response -> Message since it's both input and output (and response implies output only) 
        executor_config = ExecutorAgentConfig(
            id="ExecutorAgent",
            lm_config=executor_lm_config,
            target_host=self.init_phase_message.target_host,
            initial_prompt=self.init_phase_message.initial_prompt

        )

        exploit_config = ExploitAgentConfig(
            id="ExploitAgent",
            bounty_dir=os.path.join("bounties", f"bounty_{self.init_phase_message.bounty_number}")
        )

        return [
            ("ExecutorAgent", executor_config),
            ("ExploitAgent", exploit_config)
        ]
    
    def define_resources(self) -> Dict[str, Tuple[Type['BaseResource'], Any]]:
        """
        Define resource classes and their configurations required by the ExploitPhase.

        Returns:
            Dict[str, Tuple[Type[BaseResource], Any]]: Mapping of resource_id to (ResourceClass, ResourceConfig).
        """
        logger.debug(f"Entering define_resources for ExploitPhase")

        tmp_dir = os.path.join("tmp")  # Assuming a default tmp directory
        exploit_files_path = os.path.join(tmp_dir, "exploit_files")
        patch_files_path = os.path.join(tmp_dir, "patch_files")
        os.makedirs(patch_files_path, exist_ok=True)
        os.makedirs(exploit_files_path, exist_ok=True)


        files_dir = self.init_phase_message.files_dir
        vulnerable_commit = self.init_phase_message.vulnerable_commit

        resource_configs = {
            "kali_env": (
                KaliEnvResource,
                KaliEnvResourceConfig(
                    task_dir=self.init_phase_message.task_dir,
                    bounty_number=self.init_phase_message.bounty_number,
                    volumes={
                        os.path.abspath(tmp_dir): {"bind": "/app", "mode": "rw"},
                        os.path.abspath(exploit_files_path): {"bind": "/app/exploit_files", "mode": "rw"},
                        os.path.abspath(patch_files_path): {"bind": "/app/patch_files", "mode": "rw"},
                        "/tmp": {"bind": "/tmp", "mode": "rw"}
                    }
                )
            ),
            "docker": (
                DockerResource,
                DockerResourceConfig()
            ),
            "init_files": (
                InitFilesResource,
                InitFilesResourceConfig(
                    task_dir=self.init_phase_message.task_dir,
                    files_dir_name=files_dir,
                    tmp_dir_name=tmp_dir,
                    vulnerable_commit=vulnerable_commit
                )
            )
        }

        setup_repo_env_script = os.path.join(str(self.init_phase_message.task_dir), "setup_repo_env.sh")
        if os.path.exists(setup_repo_env_script):
            resource_configs["repo_resource"] = (
                SetupResource,
                SetupResourceConfig(
                    task_level_setup=False,
                    task_dir=self.init_phase_message.task_dir,
                    files_dir=files_dir
                )
            )

        target_host = self.init_phase_message.repo_metadata.get("target_host")
        if target_host:
            task_server_config = SetupResourceConfig(
                task_level_setup=True,
                task_dir=self.init_phase_message.task_dir,
                files_dir=files_dir,
                bounty_number=self.init_phase_message.bounty_number,
                server_address=target_host
            )
            resource_configs["task_server"] = (SetupResource, task_server_config)

        logger.debug(f"Exiting define_resources for ExploitPhase")
        return resource_configs

    def run_one_iteration(
        self,
        phase_message: PhaseMessage,
        agent_instance: Any,
        previous_output: Optional[Message]
    ) -> Message:
        """
        1) Call the agent with the previous_message as input (if any).
        2) If ExecutorAgent produces an AnswerMessageInterface, treat as hallucination -> finalize & done.
        3) If ExploitAgent produces AnswerMessageInterface, treat as exploit success -> finalize & done.
        4) Otherwise continue.
        """
        # Prepare input message list for agent
        input_list = []
        if previous_output is not None:
            input_list.append(previous_output)

        message = agent_instance.run(input_list)
        phase_message.add_agent_message(message)

        # Determine which agent name was used in this iteration
        agent_name, _ = self._get_current_agent()

        # Check for hallucination (ExecutorAgent)
        if agent_name == "ExecutorAgent":
            if isinstance(message, AnswerMessageInterface):
                logger.info("Executor agent hallucinated an answer!")
                self._set_phase_summary("completed_with_hallucination")
                phase_message.set_complete()
                return message

        # Check for exploit success (ExploitAgent)
        elif agent_name == "ExploitAgent":
            if isinstance(message, ExploitMessageInterface):
                logger.info("Exploit successful!")
                self._set_phase_summary("exploit_success")
                phase_message.set_complete()
                phase_message.set_success()
                return message

        return message
