"""
exploit_and_patch_workflow.py

This script implements a two-phase workflow for exploiting and patching vulnerabilities in a given task repository.

The workflow consists of two main phases:
1. Exploit Phase: Attempts to find and execute an exploit for the vulnerability.
2. Patch Phase: Attempts to create a patch to fix the identified vulnerability.

The script uses InitFiles, Setup(s), KaliEnv, and Docker resources.
The script uses Executor, Exploit, and Patch agents.

Usage:
    python exploit_and_patch_workflow.py --task_repo_dir <path_to_task_repo> --bounty_number <bounty_number>
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, Optional, Tuple

from agents.dataclasses.agent_spec import AgentConfig
from agents.patch_agent.patch_agent import PatchAgent
from agents.exploit_agent.exploit_agent import ExploitAgent
from agents.executor_agent.prompt import EXPLOIT_AND_PATCH_PROMPT, STOP_TOKEN
from agents.executor_agent.executor_agent import ExecutorAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.kali_env_resource import KaliEnvResource
from resources.setup_resource import SetupResource
from resources.utils import *
from responses.answer_response_interface import AnswerResponseInterface
from responses.response import Response
from utils.logger import get_main_logger
from utils.workflow_logger import workflow_logger

logger = get_main_logger(__name__)

# Constants
NETWORK_NAME = "shared_net"
EXECUTOR_AGENT = "executor_agent"
EXPLOIT_AGENT = "exploit_agent"
PATCH_AGENT = "patch_agent"
EXPLOIT_REPORT_FILE_PATH = "formatted_exploit_report.txt"
WORKFLOW_NAME = "exploit_patch"

def parse_args() -> argparse.Namespace:
    """
    Parse command-line arguments.

    Returns:
        argparse.Namespace: Parsed arguments
    """
    parser = argparse.ArgumentParser(description="Run the exploit and patch workflow")
    parser.add_argument(
        "--task_repo_dir", type=str, required=True, help="The directory of the task repo"
    )
    parser.add_argument(
        "--bounty_number", type=str, required=True,
        help="The bounty number for the given task"
    )
    return parser.parse_args()


def read_bounty_report(bounty_dir: str) -> str:
    """
    Read the bounty report from a file in the bounty directory.

    Args:
        bounty_dir (str): Path to the bounty directory

    Returns:
        str: Bounty report or empty string if file not found
    """
    file_path = os.path.join(bounty_dir, EXPLOIT_REPORT_FILE_PATH)
    
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        logger.warning(f"Bounty report file not found: {file_path}")
        return ""

def setup_resources(task_repo_dir: Path, bounty_number: str, repo_metadata: Dict, vulnerable_commit: str) -> None:
    """
    Set up necessary resources for the workflow.

    Args:
        task_repo_dir (Path): Path to the task repository
        bounty_number (str): Bounty number
        repo_metadata (Dict): Repository metadata
        vulnerable_commit (str): Vulnerable commit hash
    """
    files_dir, tmp_dir = "codebase", "tmp"
    
    InitFilesResource(
        task_repo_dir=task_repo_dir,
        files_dir_name=files_dir,
        tmp_dir_name=tmp_dir,
        exploit_files_dir_name=None,
        vulnerable_commit=vulnerable_commit
    )
    SetupResource(task_level_setup=False, task_repo_dir=task_repo_dir, files_dir=files_dir)
    SetupResource(
        task_level_setup=True,
        task_repo_dir=task_repo_dir,
        files_dir=files_dir,
        bounty_number=bounty_number,
        server_address=repo_metadata.get("target_host")
    )

    exploit_files_path = os.path.join(task_repo_dir, tmp_dir, "exploit_files")
    os.makedirs(exploit_files_path, exist_ok=True)
    logger.info(f"Created exploit_files directory at: {exploit_files_path}")

    patch_files_path = os.path.join(task_repo_dir, tmp_dir, "patch_files")
    os.makedirs(patch_files_path, exist_ok=True)
    logger.info(f"Created patch_files directory at: {patch_files_path}")

    KaliEnvResource(
        "KaliEnv",
        task_repo_dir=task_repo_dir,
        bounty_number=bounty_number,
        volumes={
            os.path.join(task_repo_dir, tmp_dir): {"bind": "/app", "mode": "rw"},
            exploit_files_path: {"bind": "/app/exploit_files", "mode": "rw"},
            patch_files_path: {"bind": "/app/patch_files", "mode": "rw"},
            "/tmp": {"bind": "/tmp", "mode": "rw"}
        }
    )

    DockerResource("DockerHelper")

def run_exploit_phase(executor_agent: ExecutorAgent, exploit_agent: ExploitAgent, max_iterations: int) -> Tuple[Optional[Response], Optional[str], int]:
    """
    Run the exploit phase of the workflow.

    Args:
        executor_agent (ExecutorAgent): The executor agent
        exploit_agent (ExploitAgent): The exploit agent
        max_iterations (int): Maximum number of iterations

    Returns:
        Tuple[Optional[str], int]: Exploit directory if successful and iterations used, (None, max_iterations) otherwise
    """
    prev_response = None
    for iteration in range(max_iterations):
        with workflow_logger.iteration(iteration + 1) as iteration_ctx:
            # EXECUTOR AGENT step
            with iteration_ctx.interaction(EXECUTOR_AGENT, prev_response if iteration > 0 else None) as interaction:
                executor_response = executor_agent.run([] if iteration == 0 else [prev_response])
                interaction.set_output(executor_response)

            if isinstance(executor_response, AnswerResponseInterface):
                workflow_logger.finalize("completed_with_hallucination")
                logger.info("Executor agent hallucinated an answer!")
                return None, None, iteration + 1

            # EXPLOIT AGENT step
            with iteration_ctx.interaction(EXPLOIT_AGENT, executor_response) as interaction:
                exploit_response = exploit_agent.run([executor_response])
                interaction.set_output(exploit_response)

            if isinstance(exploit_response, AnswerResponseInterface):
                workflow_logger.finalize("exploit_success")
                logger.info("Exploit successful!")
                return exploit_response, exploit_response.answer, iteration + 1

            prev_response = exploit_response

    workflow_logger.finalize("completed_max_iterations")
    return None, None, max_iterations

def run_patch_phase(executor_agent: ExecutorAgent, patch_agent: PatchAgent, exploit_iterations: int, initial_response: Response) -> bool:
    """
    Run the patch phase of the workflow.

    Args:
        executor_agent (ExecutorAgent): The executor agent
        patch_agent (PatchAgent): The patch agent
        exploit_iterations (int): Number of iterations from the exploit phase
        initial_response (str): Initial response from the exploit phase

    Returns:
        bool: True if patch was successful, False otherwise
    """
    prev_response = initial_response
    for iteration in range(exploit_iterations, executor_agent.config.max_iterations):
        with workflow_logger.iteration(iteration + 1) as iteration_ctx:
            # EXECUTOR AGENT step
            with iteration_ctx.interaction(EXECUTOR_AGENT, prev_response) as interaction:
                executor_response = executor_agent.run([prev_response])
                interaction.set_output(executor_response)

            if isinstance(executor_response, AnswerResponseInterface):
                workflow_logger.finalize("completed_with_hallucination")
                logger.info("Executor agent hallucinated an answer!")
                return False

            # PATCH AGENT step
            with iteration_ctx.interaction(PATCH_AGENT, executor_response) as interaction:
                patch_response = patch_agent.run([executor_response])
                interaction.set_output(patch_response)

            if isinstance(patch_response, AnswerResponseInterface):
                workflow_logger.finalize("completed_success")
                logger.info("Patch Success!")
                return True

            prev_response = patch_response

    workflow_logger.finalize("completed_max_iterations")
    return False

def git_checkout_and_rename(repo_path):
    try:
        # Try to checkout main
        subprocess.run(["git", "checkout", "main"], cwd=repo_path, check=True, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError:
        # If main doesn't exist, try to checkout master
        try:
            subprocess.run(["git", "checkout", "master"], cwd=repo_path, check=True)
            
            # Rename master to main
            subprocess.run(["git", "branch", "-m", "master", "main"], cwd=repo_path, check=True)
            
            # Push the change to the remote repository
            # Note: This step is optional and depends on whether you want to update the remote
            # subprocess.run(["git", "push", "-u", "origin", "main"], cwd=repo_path, check=True)
            
            print("Renamed 'master' branch to 'main'")
        except subprocess.CalledProcessError as e:
            print(f"Error: Unable to checkout 'master' or rename to 'main': {e}")
            raise

def main() -> None:
    """Main function to run the exploit and patch workflow."""
    args = parse_args()

    task_repo_dir = Path(args.task_repo_dir).resolve()
    bounty_number = str(args.bounty_number)

    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)

    executor_agent_config = AgentConfig(
        model='openai/o3-mini-2024-12-17',
        max_output_tokens=25000,
        max_input_tokens=25000,
        max_iterations=25,
        max_iterations_stored_in_memory=3,
        use_helm=False
    )
    
    workflow_logger.initialize(
        workflow_name=WORKFLOW_NAME,
        logs_dir=str(logs_dir),
        task_repo_dir=str(args.task_repo_dir),
        bounty_number=bounty_number,
        model_config=executor_agent_config.__dict__
    )

    if not docker_network_exists(NETWORK_NAME):
        logger.info(f"Creating Docker network: {NETWORK_NAME}")
        run_command(["docker", "network", "create", NETWORK_NAME])

    repo_metadata = read_repo_metadata(str(task_repo_dir))
    bounty_metadata = read_bounty_metadata(str(task_repo_dir), bounty_number)



    vulnerable_commit = bounty_metadata['vulnerable_commit']
    run_command(["git", "checkout", vulnerable_commit], str(task_repo_dir / "codebase"))

    if not bounty_metadata.get('patch'):
        vulnerable_files = []
    else: 
        vulnerable_files = [
            os.path.relpath(value, start="codebase")
            for _, value in bounty_metadata['patch'].items()
            if os.path.exists(os.path.join(str(task_repo_dir), value))
        ]
    
    git_checkout_and_rename(str(task_repo_dir / "codebase"))

    bounty_dir = os.path.join(task_repo_dir, "bounties", f"bounty_{bounty_number}")
    bounty_report = read_bounty_report(bounty_dir)

    prompt = EXPLOIT_AND_PATCH_PROMPT.format(
        task_description=bounty_report,
        stop_token=STOP_TOKEN,
        target_host=repo_metadata["target_host"],
    )

    setup_resources(task_repo_dir, bounty_number, repo_metadata, vulnerable_commit)

    workflow_logger.add_metadata("vulnerable_files", vulnerable_files)
    workflow_logger.add_metadata("bounty_report", bounty_report)
    workflow_logger.add_metadata("repo_metadata", repo_metadata)
    workflow_logger.add_metadata("bounty_metadata", bounty_metadata)

    executor_agent = ExecutorAgent(
        config=executor_agent_config,
        initial_prompt=prompt,
        logger=workflow_logger,
        target_host=repo_metadata["target_host"]
    )
    
    bounty_dir = os.path.join("bounties", f"bounty_{bounty_number}")
    patch_agent = PatchAgent(bounty_dir=bounty_dir, exploit_files_dir=None, use_verify_script=False)
    exploit_agent = ExploitAgent(bounty_dir=bounty_dir)

    max_iterations = executor_agent_config.max_iterations

    # Phase 1: Exploit Phase
    exploit_phase_response, exploit_directory, exploit_iterations = run_exploit_phase(executor_agent, exploit_agent, max_iterations)

    if not exploit_directory:
        logger.info("Exploit phase failed to find a successful exploit.")
        return

    # Phase 2: Patch Phase
    remaining_iterations = max_iterations - exploit_iterations

    if remaining_iterations <= 0:
        logger.info("No iterations left for patching.")
        workflow_logger.finalize("completed_no_iterations_left_for_patch")
        return

    logger.info(f"Starting patch phase with {remaining_iterations} iterations remaining.")
    patch_agent.exploit_files_dir = exploit_directory.split("Answer: ")[-1].strip()
    patch_success = run_patch_phase(executor_agent, patch_agent, exploit_iterations, exploit_phase_response)

    if not patch_success:
        logger.info("Patch phase failed to create a successful patch.")
        workflow_logger.finalize("completed_patch_failed")
        return

    workflow_logger.finalize("completed_success")
    logger.info("Workflow completed successfully.")

if __name__ == "__main__":
    main()