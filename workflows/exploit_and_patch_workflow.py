from pathlib import Path
from agents.executor_agent.prompt import EXPLOIT_AND_PATCH_PROMPT, STOP_TOKEN
from phases.base_phase import PhaseConfig
from phases.exploit_phase import ExploitPhase
from phases.patch_phase import PatchPhase
from resources.utils import read_exploit_report
from utils.logger import get_main_logger
from workflows.bounty_workflow import BountyWorkflow

logger = get_main_logger(__name__)

class ExploitAndPatchWorkflow(BountyWorkflow):
    """Workflow for exploiting and patching vulnerabilities"""

    def __init__(self, task_repo_dir: Path, bounty_number: str, interactive: bool = False):
        workflow_id = "exploit_and_patch_workflow"
        super().__init__(task_repo_dir, bounty_number, workflow_id, interactive)     

    def create_phases(self):
        """Define and register phases specific to ExploitAndPatchWorkflow."""
        exploit_phase_config = PhaseConfig(
            phase_name="ExploitPhase",
            max_iterations=10
        )

        exploit_phase = ExploitPhase(
            phase_config=exploit_phase_config,
            workflow=self,
        )
        
        # Register the PatchPhase
        # self.register_phase(exploit_phase)
        logger.info(f"ExploitPhase registered with config: {exploit_phase_config}")

        # Initialize PatchPhase with its PhaseConfig
        patch_phase_config = PhaseConfig(
            phase_name="PatchPhase",
            max_iterations=10
        )

        patch_phase = PatchPhase(
            phase_config=patch_phase_config,
            workflow=self,
        )

        # Register the PatchPhase
        # self.register_phase(patch_phase)

        exploit_phase >> patch_phase
        exploit_phase >> taskify_phase
        
        self.register_root_phase(exploit_phase)
        """
        handled by phase or by workflow, phase.parent, phase.childrens / the phase graph. should phases be aware or just workflow? perhaps phase is sensify

        node structure. phases are just nodes in a workflow

        agents are nodes within a phase
        
        idea: could we have dynamic phase generation, i.e. i find a new task and i append it down? vs static phases. Or the dynamicness part of agents? or
        find_task_phase >>

        are there conditions that then affect the phases we want to run. conditional variables of sorts. how to handle / define

        necessary complexity for expressivity / power
        useless complexity bc bad design

        The challenge with dynamic allocation is that we cannot leverage the resourcemanager as easily to compute a static graph.
        """

        logger.info(f"PatchPhase registered with config: {patch_phase_config}")


    def get_initial_prompt(self):
        """
        Provide the initial prompt for the workflow by reading the exploit report.

        Returns:
            str: The formatted initial prompt.
        """
        exploit_report = read_exploit_report(self.task_repo_dir, self.bounty_number)
        prompt = EXPLOIT_AND_PATCH_PROMPT.format(
            task_description=exploit_report,
            stop_token=STOP_TOKEN,
            target_host=self.repo_metadata["target_host"],
        )
        return prompt

def main() -> None:
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Run the exploit and patch workflow")
    parser.add_argument("--task_repo_dir", type=str, help="The directory of the task repo")
    parser.add_argument("--bounty_number", type=str, help="The bounty number")
    parser.add_argument("--interactive", action="store_true", help="Run in interactive mode")
    args = parser.parse_args()
    
    # Create logs directory
    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)
    
    # Run workflow
    workflow = ExploitAndPatchWorkflow(Path(args.task_repo_dir), args.bounty_number, args.interactive)
    workflow.run()

if __name__ == "__main__":
    main()
