import os
from pathlib import Path

from agents.dataclasses.agent_lm_spec import AgentLMConfig
from agents.patch_agent.patch_agent import PatchAgent
from agents.exploit_agent.exploit_agent import ExploitAgent
from agents.executor_agent.prompt import EXPLOIT_AND_PATCH_PROMPT, STOP_TOKEN
from agents.executor_agent.executor_agent import ExecutorAgent
from phases.base_phase import PhaseConfig
from phases.exploit_phase import ExploitPhase
from phases.patch_phase import PatchPhase
from resources.docker_resource import DockerResource
from resources.kali_env_resource import KaliEnvResource
from resources.utils import docker_network_exists, run_command
from utils.logger import get_main_logger

logger = get_main_logger(__name__)

class ExploitAndPatchWorkflow(BaseWorkflow):
    """Workflow for exploiting and patching vulnerabilities"""
    
    PHASES = [ExploitPhase, PatchPhase]
    # Agents = ExecutorAgent, ExploitAgent, PatchAgent
    # Resource =  KaliEnvResource, DockerResource (InitFilesResource, (maybe SetupFilesResource (2x)) handled in super)
    exploit_files_path = None
    patch_files_path = None

    def __init__(self, task_repo_dir: Path, bounty_number: str, interactive: bool = False):
        workflow_id = "exploit_and_patch_workflow"
        super().__init__(task_repo_dir, bounty_number, workflow_id, interactive)
        
    def setup_init(self) -> None:
        """Setup initial state of the workflow"""
        network_name = "shared_net"
        if not docker_network_exists(network_name):
            logger.info(f"Creating Docker network: {network_name}")
            run_command(["docker", "network", "create", network_name])

        # Setup exploit and patch directories
        tmp_dir = os.path.join(str(self.task_repo_dir), "tmp")
        self.exploit_files_path = os.path.join(tmp_dir, "exploit_files")
        self.patch_files_path = os.path.join(tmp_dir, "patch_files")
        
        os.makedirs(self.exploit_files_path, exist_ok=True)
        os.makedirs(self.patch_files_path, exist_ok=True)
        
        logger.info(f"Created exploit_files directory at: {self.exploit_files_path}")
        logger.info(f"Created patch_files directory at: {self.patch_files_path}")
        
        # Read exploit report if exists
        bounty_dir = os.path.join("bounties", f"bounty_{self.bounty_number}")
        report_path = os.path.join(self.task_repo_dir, bounty_dir, "formatted_exploit_report.txt")
        try:
            with open(report_path, 'r') as f:
                self.exploit_report = f.read()
        except FileNotFoundError:
            logger.warning(f"Exploit report not found at: {report_path}")
            self.exploit_report = ""

        self.workflow_logger.add_metadata("exploit_files_path", self.exploit_files_path)
        self.workflow_logger.add_metadata("patch_files_path", self.patch_files_path)
        self.workflow_logger.add_metadata("exploit_report", self.exploit_report)

    def define_resources(self) -> None:
        super().__init__(self)
                
        # Setup Kali environment and Docker
        kali_env_config = KaliEnvResourceConfig(
            task_repo_dir=self.task_repo_dir,
            bounty_number=self.bounty_number,
            volumes={
                os.path.abspath(os.path.join(str(self.task_repo_dir), tmp_dir)): {"bind": "/app", "mode": "rw"},
                os.path.abspath(self.exploit_files_path): {"bind": "/app/exploit_files", "mode": "rw"},
                os.path.abspath(self.patch_files_path): {"bind": "/app/patch_files", "mode": "rw"},
                "/tmp": {"bind": "/tmp", "mode": "rw"}
            }
        )
        self.register_resource("KaliEnv", KaliEnvResource, kali_env_config)

        docker_config = DockerResourceConfig()
        self.register_resource("DockerHelper", DockerResource, docker_config)

    def get_initial_prompt(self):
        prompt = EXPLOIT_AND_PATCH_PROMPT.format(
            task_description=self.exploit_description or "",
            stop_token=STOP_TOKEN,
            target_host=self.repo_metadata["target_host"],
        )
        return prompt
    
    def setup_agents(self) -> None:
        """Setup and configure agents"""
        # Configure agents
        agent_config = AgentLMConfig(
            model='openai/o3-mini-2024-12-17',
            max_output_tokens=25000,
            max_input_tokens=25000,
            max_iterations=5,
            max_iterations_stored_in_memory=3,
            use_helm=False
        )
        
        # Create agents
        self.executor_agent = ExecutorAgent(
            config=agent_config,
            # initial_prompt=prompt,
            logger=self.workflow_logger,
            target_host=self.repo_metadata["target_host"]
        )
        self.workflow_logger.add_agent("ExecutorAgent", self.executor_agent)
        
        self.exploit_agent = ExploitAgent(bounty_dir=os.path.join("bounties", f"bounty_{self.bounty_number}"))
        self.workflow_logger.add_agent("ExploitAgent", self.exploit_agent)
        
        self.patch_agent = PatchAgent(bounty_dir=os.path.join("bounties", f"bounty_{self.bounty_number}"))
        self.workflow_logger.add_agent("PatchAgent", self.patch_agent)

    def setup_phases(self) -> None:
        """Setup workflow phases"""
        super().setup_phases()

        # Configure exploit phase
        exploit_config = PhaseConfig(
            phase_idx=0,
            phase_name="exploit",
            max_iterations=6,
            agents=[
                ("executor_agent", self.executor_agent),
                ("exploit_agent", self.exploit_agent)
            ],
            interactive=self.interactive
        )
        self.config.phase_configs.append(exploit_config)
        
        # Configure patch phase
        patch_config = PhaseConfig(
            phase_idx=1,
            phase_name="patch",
            max_iterations=2,
            agents=[
                ("executor_agent", self.executor_agent),
                ("patch_agent", self.patch_agent)
            ],
            interactive=self.interactive
        )
        self.config.phase_configs.append(patch_config)


import os
from pathlib import Path
from agents.dataclasses.agent_lm_spec import AgentConfig, AgentLMConfig
from agents.executor_agent.executor_agent import ExecutorAgent
from phases.base_phase import PhaseConfig
from phases.patch_phase import PatchPhase
from resources.configs.init_files_resource_config import InitFilesResourceConfig
from resources.docker_resource import DockerResource, DockerResourceConfig
from resources.init_files_resource import InitFilesResource
from resources.kali_env_resource import KaliEnvResource, KaliEnvResourceConfig
from resources.setup_resource import SetupResource, SetupResourceConfig
from resources.utils import read_bounty_metadata, read_repo_metadata
from workflows.base_workflow import BaseWorkflow, WorkflowConfig

#handling of optional resources todo

class PatchWorkflow(BaseWorkflow):
    """Workflow for patching vulnerabilities"""
    
    PHASES = [PatchPhase]
    # Agents = ExecutorAgent, PatchAgent
    # Resource = InitFilesResource, (maybe SetupFilesResource (2x)), KaliEnvResource, DockerResource
    
    # def __init__(self, task_repo_dir: Path, bounty_number: str):
    #     self.task_repo_dir = task_repo_dir
    #     self.bounty_number = bounty_number
    #     self.repo_metadata = read_repo_metadata(str(task_repo_dir))
    #     self.bounty_metadata = read_bounty_metadata(str(task_repo_dir), bounty_number)
        
    #     # Validate patch is available
    #     if not self.bounty_metadata['patch']:
    #         raise ValueError(f"Patching not available for {task_repo_dir.name}")
            
    #     # Setup workflow config
    #     config = WorkflowConfig(
    #         name="patch_workflow",
    #         max_iterations=25,
    #         logs_dir=Path("logs"),
    #         task_repo_dir=task_repo_dir,
    #         bounty_number=int(bounty_number),
    #         metadata={
    #             "repo_metadata": self.repo_metadata,
    #             "bounty_metadata": self.bounty_metadata
    #         }
    #     )
    #     super().__init__(config)
        
    #     # Store workflow-specific data
    #     self.vulnerable_files = []
    #     self.exploit_description = ""
    #     self.executor_agent = None
    #     self.patch_agent = None

    def define_agents(self) -> None:
        """Configure agents"""
        # Format exploit description
        vulnerable_files_formatted = ", ".join(f"`{file}`" for file in self.vulnerable_files)
        self.exploit_description = f"""
        {self.bounty_metadata["exploit_prompt"]} 
        The path to the vulnerable file(s) is {vulnerable_files_formatted}. 
        """
        
        # Configure and create agents
        executor_lm_agent_config = AgentLMConfig(
            model='openai/o3-mini-2024-12-17',
            max_output_tokens=25000,
            max_input_tokens=25000,
            max_iterations=25,
            max_iterations_stored_in_memory=3,
            use_helm=False
        )
        patch_prompt = PATCH_PROMPT.format(
            task_description=self.exploit_description,
            stop_token=STOP_TOKEN,
            target_host=self.repo_metadata["target_host"],
        )
        
        executor_agent_config = ExecutorAgentConfig(
            config=executor_lm_agent_config,
            initial_prompt=patch_prompt,
            logger=self.workflow_logger,
            target_host=self.repo_metadata["target_host"]
        )
        self.register_agent("ExecutorAgent", ExecutorAgent, executor_agent_config)
        
        patch_agent_config = PatchAgentConfig(
            bounty_dir=os.path.join("bounties", f"bounty_{self.bounty_number}")
            )
        self.register_agent("PatchAgent", patch_agent_config)

    def define_phases(self) -> None:
        super().define_phases()

        # Configure patch phase
        phase_config = PhaseConfig(
            phase_idx=0,
            phase_name="patch",
            max_iterations=25,
            agents=[
                ("executor_agent", self.executor_agent),
                ("patch_agent", self.patch_agent)
            ]
        )
        self.register_phase(PatchPhase, phase_config)

def main() -> None:
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Run the exploit and patch workflow")
    parser.add_argument("--task_repo_dir", type=str, help="The directory of the task repo")
    parser.add_argument("--bounty_number", type=str, help="The bounty number")
    parser.add_argument("--interactive", action="store_true", help="Run in interactive mode")
    args = parser.parse_args()
    
    # Create logs directory
    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)
    
    # Run workflow
    workflow = ExploitAndPatchWorkflow(Path(args.task_repo_dir), args.bounty_number, args.interactive)
    workflow.run()

if __name__ == "__main__":
    main()
