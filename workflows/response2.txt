Introducing a dedicated ResourceManager allows us to cleanly separate resource scheduling from the workflow logic. It takes into account each phase’s required resources, computes when each resource should be initialized and released, and dynamically manages them. 

The approach is as follows: 

• Each PhaseConfig specifies the resources needed for that phase (often aggregated from its agents). 
• The ResourceManager analyzes all phases, determining for each resource the first phase that requires it (initialization phase) and the last phase that uses it (termination phase). 
• During workflow execution, right before starting a phase, the manager allocates any resources that begin at that phase. Once a phase ends, it releases any resources scheduled to terminate at that phase. 

This ensures efficient resource usage by avoiding unnecessary holding of resources between phases. 

Below is the revised code integrating a ResourceManager: 

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Any

from phases.base_phase import BasePhase, PhaseConfig
from utils.workflow_logger import workflow_logger
from responses.response import Response

class WorkflowStatus(Enum):
    """Status of workflow execution"""
    INITIALIZED = "initialized"
    INCOMPLETE = "incomplete"
    COMPLETED_SUCCESS = "completed_success"
    COMPLETED_FAILURE = "completed_failure"
    COMPLETED_MAX_ITERATIONS = "completed_max_iterations"

@dataclass
class WorkflowConfig:
    """Configuration for a workflow"""
    name: str
    max_iterations: int
    logs_dir: Path
    task_repo_dir: Path
    bounty_number: int
    metadata: Dict[str, Any] = field(default_factory=dict)
    phase_configs: List[PhaseConfig] = field(default_factory=list)

class ResourceManager:
    """
    Manages resource allocation and release based on phase schedules.
    Each PhaseConfig is assumed to contain a list of required resources.
    """
    def __init__(self, phase_configs: List[PhaseConfig]):
        self.phase_configs = phase_configs
        self.start_dict: Dict[int, List[Any]] = {}
        self.end_dict: Dict[int, List[Any]] = {}
        self._compute_schedule()

    def _compute_schedule(self) -> None:
        # Determine for each resource the first and last phase it is needed.
        schedule: Dict[Any, (int, int)] = {}
        for idx, phase in enumerate(self.phase_configs):
            # Assume phase.resources is a list of resource objects required by this phase.
            for resource in getattr(phase, 'resources', []):
                if resource in schedule:
                    start, end = schedule[resource]
                    schedule[resource] = (min(start, idx), max(end, idx))
                else:
                    schedule[resource] = (idx, idx)
        # Build quick lookup dictionaries for allocation and release times.
        for resource, (start, end) in schedule.items():
            self.start_dict.setdefault(start, []).append(resource)
            self.end_dict.setdefault(end, []).append(resource)

    def allocate_for_phase(self, phase_idx: int) -> None:
        # Allocate resources that are scheduled to start in this phase.
        for resource in self.start_dict.get(phase_idx, []):
            # Each resource is expected to have an allocate() method.
            resource.allocate()

    def release_for_phase(self, phase_idx: int) -> None:
        # Release resources that are scheduled to end in this phase.
        for resource in self.end_dict.get(phase_idx, []):
            # Each resource is expected to have a release() method.
            resource.release()

class BaseWorkflow(ABC):
    """
    Base class for defining workflows that coordinate phases and their agents.
    """

    def __init__(self, config: WorkflowConfig):
        """Initialize workflow with configuration"""
        self.config = config
        self.status = WorkflowStatus.INITIALIZED
        self._current_phase_idx = 0
        self._workflow_iteration_count = 0
        self.resource_manager: Optional[ResourceManager] = None

        # Initialize workflow logger
        self.workflow_logger = workflow_logger
        self.workflow_logger.initialize(
            workflow_name=config.name,
            logs_dir=str(config.logs_dir),
            task_repo_dir=str(config.task_repo_dir),
            bounty_number=str(config.bounty_number)
        )

        # Add workflow metadata
        for key, value in config.metadata.items():
            self.workflow_logger.add_metadata(key, value)

    @abstractmethod
    def setup_init(self) -> None:
        """Setup workflow initialization"""
        pass

    @abstractmethod
    def setup_resources(self) -> None:
        """Setup all required resources (if any global initialization is needed)"""
        pass

    @abstractmethod
    def setup_agents(self) -> None:
        """Setup and configure agents"""
        pass

    def setup_phases(self) -> None:
        """
        Setup workflow phases.
        Removing global resource allocation since ResourceManager handles dynamic resource management.
        """
        try:
            self.setup_init()
            self.setup_agents()
        except Exception as e:
            self.status = WorkflowStatus.INCOMPLETE
            raise e

    def _validate_phase_configs(self) -> None:
        """Validate phase configurations before execution"""
        if not self.config.phase_configs:
            raise ValueError("No phase configurations provided")

        # Validate phase numbers are sequential starting from 1
        phase_numbers = [p.phase_number for p in self.config.phase_configs]
        if sorted(phase_numbers) != list(range(1, len(phase_numbers) + 1)):
            raise ValueError("Phase numbers must be sequential starting from 1")

    @abstractmethod
    def create_phase(self, phase_config: PhaseConfig, prev_response: Optional[Response]) -> BasePhase:
        """
        Create a phase instance from config.
        Must be implemented by subclasses to return appropriate phase types.
        """
        pass

    def run(self) -> None:
        """
        Execute the workflow by running phases in sequence,
        dynamically managing resources between phases using ResourceManager.
        """
        try:
            self.setup_phases()
            self._validate_phase_configs()
            # Initialize ResourceManager after validating phases.
            self.resource_manager = ResourceManager(self.config.phase_configs)
            self.status = WorkflowStatus.INCOMPLETE

            prev_response = None
            phase_success = True

            for phase_idx, phase_config in enumerate(self.config.phase_configs):
                self._current_phase_idx = phase_idx

                # Allocate resources for current phase
                self.resource_manager.allocate_for_phase(phase_idx)

                try:
                    # Create and run phase
                    phase = self.create_phase(phase_config, prev_response)
                    phase_response, phase_success = phase.run_phase()
                finally:
                    # Release resources scheduled to end after this phase
                    self.resource_manager.release_for_phase(phase_idx)

                prev_response = phase_response
                if not phase_success:
                    self.status = WorkflowStatus.COMPLETED_FAILURE
                    break

                self._workflow_iteration_count += 1
                if self._workflow_iteration_count >= self.config.max_iterations:
                    self.status = WorkflowStatus.COMPLETED_MAX_ITERATIONS
                    break

            # If all phases completed successfully
            if phase_success and self._current_phase_idx == len(self.config.phase_configs) - 1:
                self.status = WorkflowStatus.COMPLETED_SUCCESS

            self.workflow_logger.finalize(self.status.value)

        except Exception as e:
            self.status = WorkflowStatus.INCOMPLETE
            self.workflow_logger.finalize(self.status.value)
            raise e

    @property
    def current_phase(self) -> Optional[PhaseConfig]:
        """Get current phase configuration"""
        if 0 <= self._current_phase_idx < len(self.config.phase_configs):
            return self.config.phase_configs[self._current_phase_idx]
        return None

In this design: 

• The ResourceManager computes a schedule once using all phase configurations. 
• Before each phase execution, resources scheduled to start at that phase are allocated. 
• Immediately after phase execution, resources scheduled to terminate at that phase are released. 

This approach efficiently manages resources by precisely matching allocation to the phases’ needs and maintains a clear separation of concerns.