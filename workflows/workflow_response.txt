Could we do something smarter, more akin to 2. Introduce a dedicated ResourceManager. I think the approach would basically be:

Each Agent defines the Resources it needs. 
Each Phase has N associated Agents with K Resources.
Then, the ResourceManager dynamically handles Resource allocation and release based on the defined Resources.

This would involve creating a ResourceGraph (or PhaseGraph).
Here, you start at the first phase. 

Let me write some pseudocode:

root_phase = self.root_phase
resources = root_phase.resources
for child in root_phase.children:
    # 

Actually, we don't need to compute the entire graph beforehand.
Well we do if we want to be smart (i.e. know whether to retain a resource later)
Ok let's continue with psuedocode

root_phase = self.root_phase
resources = root_phase.resources
for child in root_phase.children:
    #go through children and see which resources are retained until when

Then for each Resource, there is an initialization phase and a termination phase. i.e. 

imagine:
Resources: R1, R2, R3
Phases: P1, P2, P3

P1: R1, R2
P2: R1, R3
P3: R2

Then:
R1: Init_phase P1, termination P2
R2: Init_phase P1, termination P3
R3: Init_phase P2, termination P2


One effective solution is to shift resource allocation from a one-time global setup to a dynamic, per–phase process. This means that instead of allocating all resources at the beginning of the workflow, resources are allocated just before each phase runs and then released immediately afterward. 

Possible approaches included: 

1. Continue global allocation at startup: 
 • Pros: Simplest to implement. 
 • Cons: Can lead to resource overcommitment, poor efficiency, and potential out-of-memory errors.

2. Introduce a dedicated ResourceManager: 
 • Pros: Separates concerns, encapsulates resource logic. 
 • Cons: Introduces additional abstraction layers, increasing complexity for a relatively straightforward need.

3. Dynamic per–phase resource management (chosen): 
 • Pros: Efficient use of resources, minimizes memory footprint, reduces OOM risk. 
 • Cons: Requires additional methods and more complex orchestration, but offers the best balance of efficiency and control.

By adding abstract methods to allocate and release resources for each phase, the BaseWorkflow can automatically handle resource management on a per–phase basis. The setup_phases method is updated to remove the global resource setup, delegating resource handling to the run loop. 

Here’s the updated code with the preferred solution implemented: 

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

from phases.base_phase import BasePhase, PhaseConfig
from utils.workflow_logger import workflow_logger
from responses.response import Response

class WorkflowStatus(Enum):
    """Status of workflow execution"""
    INITIALIZED = "initialized"
    INCOMPLETE = "incomplete"
    COMPLETED_SUCCESS = "completed_success"
    COMPLETED_FAILURE = "completed_failure"
    COMPLETED_MAX_ITERATIONS = "completed_max_iterations"

@dataclass
class WorkflowConfig:
    """Configuration for a workflow"""
    name: str
    max_iterations: int
    logs_dir: Path
    task_repo_dir: Path
    bounty_number: int
    metadata: Dict[str, Any] = field(default_factory=dict)
    phase_configs: List[PhaseConfig] = field(default_factory=list)

class BaseWorkflow(ABC):
    """
    Base class for defining workflows that coordinate phases and their agents.
    """

    def __init__(self, config: WorkflowConfig):
        """Initialize workflow with configuration"""
        self.config = config
        self.status = WorkflowStatus.INITIALIZED
        self._current_phase_idx = 0
        self._workflow_iteration_count = 0
        
        # Initialize workflow logger
        self.workflow_logger = workflow_logger
        self.workflow_logger.initialize(
            workflow_name=config.name,
            logs_dir=str(config.logs_dir),
            task_repo_dir=str(config.task_repo_dir),
            bounty_number=str(config.bounty_number)
        )
        
        # Add workflow metadata
        for key, value in config.metadata.items():
            self.workflow_logger.add_metadata(key, value)
    
    @abstractmethod
    def setup_init(self) -> None:
        """Setup workflow initialization"""
        pass

    @abstractmethod
    def setup_resources(self) -> None:
        """Setup all required resources"""
        pass

    @abstractmethod
    def setup_agents(self) -> None:
        """Setup and configure agents"""
        pass

    def setup_phases(self) -> None:
        """
        Setup workflow phases without allocating all resources globally.
        Resource allocation will happen per phase during run.
        """
        try:
            self.setup_init()
            # Removed global resource setup; will handle per phase.
            self.setup_agents()
        except Exception as e:
            self.status = WorkflowStatus.INCOMPLETE
            raise e

    def _validate_phase_configs(self) -> None:
        """Validate phase configurations before execution"""
        if not self.config.phase_configs:
            raise ValueError("No phase configurations provided")
            
        # Validate phase numbers are sequential starting from 1
        phase_numbers = [p.phase_number for p in self.config.phase_configs]
        if sorted(phase_numbers) != list(range(1, len(phase_numbers) + 1)):
            raise ValueError("Phase numbers must be sequential starting from 1")

    @abstractmethod
    def create_phase(self, phase_config: PhaseConfig, prev_response: Optional[Response]) -> BasePhase:
        """
        Create a phase instance from config.
        Must be implemented by subclasses to return appropriate phase types.
        """
        pass

    @abstractmethod
    def allocate_resources_for_phase(self, phase_config: PhaseConfig) -> None:
        """
        Allocate resources needed for a given phase.
        Implementation should allocate only the resources 
        required by this phase.
        """
        pass

    @abstractmethod
    def release_resources_for_phase(self, phase_config: PhaseConfig) -> None:
        """
        Release resources allocated for a given phase.
        Implementation should free resources after phase completion.
        """
        pass

    def run(self) -> None:
        """
        Execute the workflow by running phases in sequence, 
        handling resource allocation dynamically per phase.
        """
        try:
            self.setup_phases()
            self._validate_phase_configs()
            self.status = WorkflowStatus.INCOMPLETE

            prev_response = None

            for phase_idx, phase_config in enumerate(self.config.phase_configs):
                self._current_phase_idx = phase_idx

                # Allocate resources for this phase
                self.allocate_resources_for_phase(phase_config)
                try:
                    # Create and run phase
                    phase = self.create_phase(phase_config, prev_response)
                    phase_response, phase_success = phase.run_phase()
                finally:
                    # Always release resources regardless of phase success/failure
                    self.release_resources_for_phase(phase_config)

                prev_response = phase_response
                if not phase_success:
                    self.status = WorkflowStatus.COMPLETED_FAILURE
                    break

                self._workflow_iteration_count += 1
                if self._workflow_iteration_count >= self.config.max_iterations:
                    self.status = WorkflowStatus.COMPLETED_MAX_ITERATIONS
                    break

            # If all phases completed successfully
            if phase_success and phase_idx == len(self.config.phase_configs) - 1:
                self.status = WorkflowStatus.COMPLETED_SUCCESS

            self.workflow_logger.finalize(self.status.value)

        except Exception as e:
            self.status = WorkflowStatus.INCOMPLETE
            self.workflow_logger.finalize(self.status.value)
            raise e

    @property
    def current_phase(self) -> Optional[PhaseConfig]:
        """Get current phase configuration"""
        if 0 <= self._current_phase_idx < len(self.config.phase_configs):
            return self.config.phase_configs[self._current_phase_idx]
        return None

This update delegates resource allocation to each phase, minimizing upfront allocation and reducing memory pressure. Subclasses then implement the new allocate/release methods according to their specific resource requirements.