import asyncio
from pathlib import Path

from phases.exploit_phase import ExploitPhase
from prompts.prompts import (
    EXPLOIT_PROMPT,
    EXPLOIT_PROMPT_VERIFY_SCRIPT,
    SEPARATOR,
    STOP_TOKEN,
    TARGET_HOST_EXPLOIT_PROMPT,
    TARGET_HOST_EXPLOIT_PROMPT_VERIFY_SCRIPT,
)
from resources.utils import read_writeup
from utils.logger import get_main_logger
from workflows.bounty_workflow import BountyWorkflow

logger = get_main_logger(__name__)


class ExploitWorkflow(BountyWorkflow):
    """Workflow for exploiting and patching vulnerabilities"""

    default_values = {
        "interactive": False,
        "use_helm": False,
        "use_mock_model": False,
        "max_input_tokens": 8192,
        "max_output_tokens": 4096,
    }

    def validate_arguments(self, kwargs):
        """
        Custom validation logic for ExploitPatchWorkflow. Checks that:
        1. Required base args are present: task_dir, bounty_number, phase_iterations
        2. Model is required only when not using mock model
        3. Both model and use_mock_model cannot be set simultaneously
        """
        super().validate_arguments(kwargs)

        # Check base required arguments
        required_base_args = ["task_dir", "bounty_number", "phase_iterations"]
        missing_args = [arg for arg in required_base_args if arg not in kwargs]
        if missing_args:
            raise ValueError(
                f"Missing required arguments for {self.name}: {', '.join(missing_args)}"
            )

        # Exactly one of (--use_mock_model, --model) should be set
        # Fail if both set
        if kwargs.get("use_mock_model", False) and "model" in kwargs:
            raise ValueError(
                f"Cannot specify both '--model' and '--use_mock_model' simultaneously. "
            )

        # Fail if neither is set
        if not kwargs.get("use_mock_model", False) and "model" not in kwargs:
            raise ValueError(f"'--model' is required when not using mock model")

    def _create_phases(self):
        """Define and create phases specific to ExploitWorkflow."""

        verify_exploit_prompt = self.bounty_metadata.get("verify_exploit_prompt", "")
        verify_check_information = (
            SEPARATOR
            + "In order for your exploit to succeed, it must pass the verification check: \n"
            + verify_exploit_prompt
            + SEPARATOR
            if verify_exploit_prompt
            else ""
        )

        # Get the task from bounty_metadata or use a default value
        task = self.bounty_metadata.get(
            "task",
            "",
        )

        # Superset of parameters for all phases
        phase_kwargs = {
            "use_mock_model": self.params.get("use_mock_model"),
            "model": self.params.get("model"),
            "helm": self.params.get("use_helm"),
            "task_dir": self.task_dir,
            "bounty_number": self.bounty_number,
            "task_description": read_writeup(self.task_dir, self.bounty_number),
            "additional_prompt_information": self.bounty_metadata.get(
                "additional_prompt_information", ""
            ),
            "stop_token": STOP_TOKEN,
            "target_host": self.repo_metadata["target_host"],
            "task": task,  # Add the task parameter for the prompt formatting
            "initial_prompt": self.initial_prompt,
            "info": self.repo_metadata.get("info", "")
            + "\n"
            + self.bounty_metadata.get("info", ""),
            # This is currently unused - TODO - maybe delete?
            "verify_check_information": verify_check_information,
            "max_input_tokens": self.params.get("max_input_tokens"),
            "max_output_tokens": self.params.get("max_output_tokens"),
            "interactive": self.interactive,
            "max_iterations": self.params.get("phase_iterations"),
        }

        exploit_phase = ExploitPhase(workflow=self, **phase_kwargs)

        self._register_root_phase(exploit_phase)

    def _get_initial_prompt(self):
        """
        Provide the initial prompt for the workflow by reading the exploit report.

        Returns:
            str: The formatted initial prompt.
        """
        # Temporary changes to test which approach is better
        # 1. provide task in bounty_metadata
        # 2. provide verify.sh and relevant files
        has_task = "task" in self.bounty_metadata

        # 1. Whether there's a target host
        # 2. Whether there's a task in bounty_metadata or we should use verify.sh
        if self.repo_metadata["target_host"]:
            if has_task:
                # Target host and task provided
                return TARGET_HOST_EXPLOIT_PROMPT
            else:
                # Target host, no task - use verify.sh
                return TARGET_HOST_EXPLOIT_PROMPT_VERIFY_SCRIPT
        else:
            if has_task:
                # No target host, task provided
                return EXPLOIT_PROMPT
            else:
                # No target host, no task - use verify.sh
                return EXPLOIT_PROMPT_VERIFY_SCRIPT
