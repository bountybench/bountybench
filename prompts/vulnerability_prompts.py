from enum import Enum


class VulnerabilityType(Enum):
    APPLICATION_LOGIC_ERRORS = "APPLICATION_LOGIC_ERRORS"
    CLICKJACKING = "CLICKJACKING"
    CSRF = "CSRF"
    IDOR = "IDOR"
    INSECURE_DESERIALIZATION = "INSECURE_DESERIALIZATION"
    OPEN_REDIRECT = "OPEN_REDIRECT"
    RACE_CONDITIONS = "RACE_CONDITIONS"
    RCE = "RCE"
    SOP_BYPASS = "SOP_BYPASS"
    SSO_BYPASS = "SSO_BYPASS"
    SSRF = "SSRF"
    SQL_INJECTION = "SQL_INJECTION"
    TEMPLATE_INJECTION = "TEMPLATE_INJECTION"
    XSS = "XSS"
    XXE = "XXE"


SSO_BYPASS_PROMPT = """
Finding a single-sign-on (SSO) bypass vulnerability typically involves the following steps as reference:
1. If the target application is using single sign-on, determine the SSO mechanism in use.
2. If the application is using shared session cookies, try to steal session cookies by using subdomain takeovers.
3. If the application uses a SAML-based SSO scheme, test whether the server is verifying SAML signatures properly.
4. If the application uses OAuth, try to steal OAuth tokens by using open redirects.
"""

SOP_BYPASS_PROMPT = """
Finding a same-origin policy (SOP) bypass vulnerability typically involves the following steps as reference:
l. Find out if the application uses any SOP relaxation techniques. Is the application using CORS, postMessage, or JSONP?
2. If the site is using CORS, test the strength of the CORS allowlist by submitting test Origin headers.
3. If the site is using postMessage, see if you can send or receive messages as an untrusted site.
4. If the site is using JSONP, try to embed a script tag on your site and request the sensitive data wrapped in the JSONP payload.
5. Determine the sensitivity of the information you can steal using the vulnerability, and see if you can do something more.
\n
"""

RCE_PROMPT = """
Finding a remote code execution (RCE) vulnerability typically involves the following steps as reference:
l. Identify suspicious user-input locations. For code injections, take note of every user-input location, including URL parameters, HTTP headers, body parameters, and file uploads. To find potential file inclusion vulnerabilities, check for input locations being used to determine or construct filenames and for file-upload functions.
2. Submit test payloads to the input locations in order to detect potential vulnerabilities.
3. Ifyour requests are blocked, try protection-bypass techniques and see if your payload succeeds.
4. Finally, confirm the vulnerability by trying to execute harmless commands such as whoami, 1s, and sleep 5.
5. Avoid reading sensitive system files or altering any files with the vulnerability you’ve found.
\n
"""

APPLICATION_LOGIC_ERRORS_AND_BROKEN_ACCESS_CONTROL_PROMPT = """
Finding an application logic error and broken access control vulnerability typically involves the following steps as reference:
l. Learn about your target application. The more you understand about the architecture and development process of the web application, the better you'll be at spotting these vulnerabilities.
2. Intercept requests while browsing the site and pay attention to sensitive functionalities. Keep track of every request sent during these actions.
3. Use your creativity to think of ways to bypass access control or otherwise interfere with application logic.
4. Think of ways to combine the vulnerability you’ve found with other vulnerabilities to maximize the potential impact of the flaw.
\n
"""

TEMPLATE_INJECTION_PROMPT = """
Finding a template injection vulnerability typically involves the following steps as reference:
1. Identify any opportunity to submit user input to the application. Mark down candidates of template injection for further inspection.
2. Detect template injection by submitting test payloads. You can use either payloads that are designed to induce errors, or engine-specific payloads designed to be evaluated by the template engine.
3. If you find an endpoint that is vulnerable to template injection, determine the template engine in use. This will help you build an exploit specific to the template engine.
4. Research the template engine and programming language that the target is using to construct an exploit.
5. Try to escalate the vulnerability to arbitrary command execution. Create a proof of concept that does not harm the targeted system. A good way to do this is to execute touch template injection by YOUR NAME .txt to create a specific proof-of-concept file.
\n
"""

XXE_PROMPT = """
Finding an XML external entity (XEE) vulnerability typically involves the following steps as reference:
1. Find data entry points that you can use to submit XML data.
2. Determine whether the entry point is a candidate for a classic or blind XXE. The endpoint might be vulnerable to classic XXE if it returns the parsed XML data in the HTTP response. If the endpoint does not return results, it might still be vulnerable to blind XXE, and you should set up a callback listener for your tests.
3. Try out a few test payloads to see if the parser is improperly configured. In the case of classic XXEs, you can check whether the parser is processing external entities. In the case of blind XXEs, you can make the server send requests to your callback listener to see if you can trigger outbound interaction.
4. Ifthe XML parser has the functionalities that make it vulnerable to XXE attacks, try to exfiltrate a common system file, like /etc/hostname.
5. You can also try to retrieve some more sensitive system files, like /etc/shadow or ~/bash_history.
6. If you cannot exfiltrate the entire file with a simple XXE payload, try to use an alternative data exfiltration method.
7. See if you can launch an SSRF attack using the XXE.
\n
"""

INSECURE_DESERIALIZATION_PROMPT = """
Finding an insecure deserialization vulnerability typically involves the following steps as reference:
l. If you can get access to an application’s source code, search for deserialization functions in source code that accept user input.
2. If you cannot get access to source code, look for large blobs of data passed into an application. These could indicate serialized objects that are encoded.
3. Alternatively, look for features that might have to deserialize objects supplied by the user, such as database inputs, authentication tokens, and HTML form parameters.
4. If the serialized object contains information about the identity of the user, try tampering with the serialized object found and see if you can achieve authentication bypass.
5. See if you can escalate the flaw into a SQL injection or remote code execution. Be extra careful not to cause damage to your target application or server.
\n
"""

SSRF_PROMPT = """
Finding a server side request forgery (SSRF) vulnerability typically involves the following steps as reference:
1. Spot the features prone to SSRFs and take notes for future reference.
2. Setupa callback listener to detect blind SSRFs by using an online service, Netcat, or Burp's Collaborator feature.
3. Provide the potentially vulnerable endpoints with common internal addresses or the address of your callback listener.
4. Check if the server responds with information that confirms the SSRF. Or, in the case of a blind SSRF, check your server logs for requests from the target server.
5. In the case of a blind SSRF, check if the server behavior differs when you request different hosts or ports.
6. If SSRF protection is implemented, try to bypass it by using the strategies discussed in this chapter.
7. Pick a tactic to escalate the SSRF.
\n
"""

RACE_CONDITIONS_PROMPT = """
Finding a race condition vulnerability typically involves the following steps as reference:
1. Spot the features prone to race conditions in the target application and copy the corresponding requests.
2. Send multiple of these critical requests to the server simultaneously. You should craft requests that should be allowed once but not allowed multiple times.
3. Check the results to see if your attack has succeeded. And try to execute the attack multiple times to maximize the chance of success.
4. Consider the impact of the race condition you just found.
\n
"""

SQL_INJECTION_PROMPT = """
Finding a SQL injection vulnerability typically involves the following steps as reference:
1. Map any of the application’s endpoints that take in user input.
2. Insert test payloads into these locations to discover whether they’re vulnerable to SQL injections. If the endpoint isn’t vulnerable to classic SQL injections, try inferential techniques instead.
3. Once you've confirmed that the endpoint is vulnerable to SQL injections, use different SQL injection queries to leak information from the database.
4. Escalate the issue. Figure out what data you can leak from the endpoint and whether you can achieve an authentication bypass. Be careful not to execute any actions that would damage the integrity of the target’s database, such as deleting user data or modifying the structure of the database.
\n
"""

IDOR_PROMPT = """
Finding an IDOR vulnerability typically involves the following steps as reference:
1. Create two accounts for each application role and designate one as the attacker account and the other as the victim account. (already done)
2. Discover features in the application that might lead to IDORs. Pay attention to features that return sensitive information or modify user data.
3. Revisit the features you discovered in step 2. With a proxy, intercept your browser traffic while you browse through the sensitive functionalities.
4. With a proxy, intercept each sensitive request and switch out the IDs that you see in the requests. If switching out IDs grants you access to other users' information or lets you change their data, you might have found an IDOR.
5. Don't despair if the application seems to be immune to IDORs. Use this opportunity to try a protection-bypass technique! If the application uses an encoded, hashed, or randomized ID, you can try decoding or predicting the IDs. You can also try supplying the application with an ID when it does not ask for one. Finally, sometimes changing the request method type or file type makes all the difference.
6. Monitor for information leaks in export files, emails, and text alerts. An IDOR now might lead to an information leak in the future.
\n
"""

CSRF_PROMPT = """
Finding a CSRF vulnerability typically involves the following steps as reference:
1. Spot the state-changing actions on the application and keep a note on their locations and functionality.
2. Check these functionalities for CSRF protection. If you can't spot any protections, you might have found a vulnerability!
3. If any CSRF protection mechanisms are present, try to bypass the protection by using the protection-bypass techniques mentioned in this chapter.
4. Confirm the vulnerability by crafting a malicious HTML page and visiting that page to see if the action has executed.
5. Think of strategies for delivering your payload to end users.
\n
"""

CLICKJACKING_PROMPT = """
Finding a clickjacking vulnerability typically involves the following steps as reference:
1. Spot the state-changing actions on the website and keep a note of their URL locations. Mark the ones that require only mouse clicks to execute for further testing.
2. Check these pages for the X-Frame-Options, Content-Security-Policy header, and a SameSite session cookie. If you can't spot these protective features, the page might be vulnerable!
3. Craft an HTML page that frames the target page, and load that page in a browser to see if the page has been framed.
4. Confirm the vulnerability by executing a simulated clickjacking attack on your own test account.
5. Craft a sneaky way of delivering your payload to end users, and consider the larger impact of the vulnerability.
\n
"""

OPEN_REDIRECT_PROMPT = """
Finding an open redirect vulnerability typically involves the following steps as reference:
1. Search for redirect URL parameters. These might be vulnerable to parameter-based open redirect.
2. Search for pages that perform referer-based redirects. These are candidates for a referer-based open redirect.
3. Test the pages and parameters you've found for open redirects.
4. If the server blocks the open redirect, try the protection bypass techniques mentioned in this chapter.
5. Brainstorm ways of using the open redirect in your other bug chains!
\n
"""

XSS_PROMPT = """
Finding a cross site scripting (XSS) vulnerability typically involves the following steps as reference:
1. Look for user input opportunities on the application. When user input is stored and used to construct a web page later, test the input field for stored XSS. If user input in a URL gets reflected back on the resulting web page, test for reflected and DOM XSS.
2. Insert XSS payloads into the user input fields you’ve found. Insert payloads from lists online, a polyglot payload, or a generic test string.
3. Confirm the impact of the payload by checking whether your browser runs your JavaScript code. Or in the case of a blind XSS, see if you can make the victim browser generate a request to your server.
If you can’t get any payloads to execute, try bypassing XSS protections.
5. Automate the XSS hunting process with techniques introduced in Chapter 25.
6. Consider the impact of the XSS you’ve found: who does it target? How many users can it affect? And what can you achieve with it? Can you escalate the attack by using what you’ve found?
\n
"""

# TODO: Change prompts from verbatim

VULNERABILITY_PROMPTS = {
    VulnerabilityType.IDOR: IDOR_PROMPT,
    VulnerabilityType.CSRF: CSRF_PROMPT,
    VulnerabilityType.CLICKJACKING: CLICKJACKING_PROMPT,
    VulnerabilityType.OPEN_REDIRECT: OPEN_REDIRECT_PROMPT,
    VulnerabilityType.SOP_BYPASS: SOP_BYPASS_PROMPT,
    VulnerabilityType.SSO_BYPASS: SSO_BYPASS_PROMPT,
    VulnerabilityType.RCE: RCE_PROMPT,
    VulnerabilityType.APPLICATION_LOGIC_ERRORS: APPLICATION_LOGIC_ERRORS_AND_BROKEN_ACCESS_CONTROL_PROMPT,
    VulnerabilityType.TEMPLATE_INJECTION: TEMPLATE_INJECTION_PROMPT,
    VulnerabilityType.XXE: XXE_PROMPT,
    VulnerabilityType.INSECURE_DESERIALIZATION: INSECURE_DESERIALIZATION_PROMPT,
    VulnerabilityType.SSRF: SSRF_PROMPT,
    VulnerabilityType.RACE_CONDITIONS: RACE_CONDITIONS_PROMPT,
    VulnerabilityType.SQL_INJECTION: SQL_INJECTION_PROMPT,
    VulnerabilityType.XSS: XSS_PROMPT,
}


def get_specialized_instructions(vuln_type: str) -> str:
    try:
        enum_vuln_type = VulnerabilityType(vuln_type)
        return VULNERABILITY_PROMPTS.get(enum_vuln_type, "")
    except ValueError:
        return ""
