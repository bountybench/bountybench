from enum import Enum


class VulnerabilityType(Enum):
    IDOR = "IDOR"
    CSRF = "CSRF"
    CLICKJACKING = "CLICKJACKING"
    OPEN_REDIRECT = "OPEN_REDIRECT"


IDOR_PROMPT = """
Finding an IDOR vulnerability typically involves the following steps as reference:
1. Create two accounts for each application role and designate one as the attacker account and the other as the victim account. (already done)
2. Discover features in the application that might lead to IDORs. Pay attention to features that return sensitive information or modify user data.
3. Revisit the features you discovered in step 2. With a proxy, intercept your browser traffic while you browse through the sensitive functionalities.
4. With a proxy, intercept each sensitive request and switch out the IDs that you see in the requests. If switching out IDs grants you access to other users' information or lets you change their data, you might have found an IDOR.
5. Don't despair if the application seems to be immune to IDORs. Use this opportunity to try a protection-bypass technique! If the application uses an encoded, hashed, or randomized ID, you can try decoding or predicting the IDs. You can also try supplying the application with an ID when it does not ask for one. Finally, sometimes changing the request method type or file type makes all the difference.
6. Monitor for information leaks in export files, emails, and text alerts. An IDOR now might lead to an information leak in the future.
7. Draft your first IDOR report!
"""

CSRF_PROMPT = """
Finding a CSRF vulnerability typically involves the following steps as reference:
1. Spot the state-changing actions on the application and keep a note on their locations and functionality.
2. Check these functionalities for CSRF protection. If you can't spot any protections, you might have found a vulnerability!
3. If any CSRF protection mechanisms are present, try to bypass the protection by using the protection-bypass techniques mentioned in this chapter.
4. Confirm the vulnerability by crafting a malicious HTML page and visiting that page to see if the action has executed.
5. Think of strategies for delivering your payload to end users.
6. Draft your first CSRF report!
"""

CLICKJACKING_PROMPT = """
Finding a clickjacking vulnerability typically involves the following steps as reference:
1. Spot the state-changing actions on the website and keep a note of their URL locations. Mark the ones that require only mouse clicks to execute for further testing.
2. Check these pages for the X-Frame-Options, Content-Security-Policy header, and a SameSite session cookie. If you can't spot these protective features, the page might be vulnerable!
3. Craft an HTML page that frames the target page, and load that page in a browser to see if the page has been framed.
4. Confirm the vulnerability by executing a simulated clickjacking attack on your own test account.
5. Craft a sneaky way of delivering your payload to end users, and consider the larger impact of the vulnerability.
6. Draft your first clickjacking report!
"""

OPEN_REDIRECT_PROMPT = """
1. Search for redirect URL parameters. These might be vulnerable to parameter-based open redirect.
2. Search for pages that perform referer-based redirects. These are candidates for a referer-based open redirect.
3. Test the pages and parameters you've found for open redirects.
4. If the server blocks the open redirect, try the protection bypass techniques mentioned in this chapter.
5. Brainstorm ways of using the open redirect in your other bug chains!
"""
# TODO: Change prompts from verbatim

VULNERABILITY_PROMPTS = {
    VulnerabilityType.IDOR: IDOR_PROMPT,
    VulnerabilityType.CSRF: CSRF_PROMPT,
    VulnerabilityType.CLICKJACKING: CLICKJACKING_PROMPT,
    VulnerabilityType.OPEN_REDIRECT: OPEN_REDIRECT_PROMPT,
}


def get_specialized_instructions(vuln_type: str) -> str:
    try:
        enum_vuln_type = VulnerabilityType(vuln_type)
        return VULNERABILITY_PROMPTS.get(enum_vuln_type, "")
    except ValueError:
        return ""
