from enum import Enum


class VulnerabilityType(Enum):
    APPLICATION_LOGIC_ERRORS = "APPLICATION_LOGIC_ERRORS"
    CLICKJACKING = "CLICKJACKING"
    CSRF = "CSRF"
    IDOR = "IDOR"
    INSECURE_DESERIALIZATION = "INSECURE_DESERIALIZATION"
    OPEN_REDIRECT = "OPEN_REDIRECT"
    RACE_CONDITIONS = "RACE_CONDITIONS"
    RCE = "RCE"
    SOP_BYPASS = "SOP_BYPASS"
    SSO_BYPASS = "SSO_BYPASS"
    SSRF = "SSRF"
    SQL_INJECTION = "SQL_INJECTION"
    TEMPLATE_INJECTION = "TEMPLATE_INJECTION"
    XSS = "XSS"
    XXE = "XXE"


SSO_BYPASS_PROMPT = """
Finding a single-sign-on (SSO) bypass vulnerability typically involves the following steps as reference:
1. First, determine the SSO mechanism in use by the target application.
2. If the application operates via shared session cookies, attempt to compromise these cookies through techniques such as subdomain takeovers.
3. In the case where a SAML-based SSO protocol is in place, verify whether the server appropriately validates SAML signatures.
4. For applications utilizing OAuth, try to obtain OAuth tokens via open redirect vulnerabilities.
"""

SOP_BYPASS_PROMPT = """
Finding a same-origin policy (SOP) bypass vulnerability typically involves the following steps as reference:
1. Assess whether the application employs any SOP relaxation techniques, such as CORS, postMessage, or JSONP.
2. If the application uses CORS, examine the robustness of the CORS allowlist by sending test Origin headers.
3. If the application uses postMessage, investigate if it’s possible to send or receive messages from an untrusted site.
4. If the application uses JSONP, try incorporating a script tag on your site to retrieve sensitive data encapsulated in the JSONP format.
5. Evaluate the sensitivity of the data that can be extracted through this vulnerability, and see if any additional actions are feasible.
\n
"""

RCE_PROMPT = """
Finding a remote code execution (RCE) vulnerability typically involves the following steps as reference:
1. Identify locations in the application where user input is permitted. For code injection vulnerabilities, take careful note of each user input location—this includes URL parameters, HTTP headers, body parameters, and file uploads. To detect potential file inclusion issues, look for inputs being used to generate or specify filenames, and for any file-upload functionalities.
2. Test these input locations by submitting various payloads to identify potential weaknesses.
3. If your requests are blocked, leverage protection-bypass techniques and see if your payloads can get through.
4. Confirm the existence of the vulnerability by attempting to execute harmless commands, like `whoami`, `ls`, or `sleep 5`.
5. Exercise caution to avoid accessing sensitive system files or making any alterations to files impacted by the vulnerability you have discovered.
\n
"""

APPLICATION_LOGIC_ERRORS_AND_BROKEN_ACCESS_CONTROL_PROMPT = """
Finding an application logic error and broken access control vulnerability typically involves the following steps as reference:
1. Familiarize yourself with the target application. A thorough understanding of the application's architecture and development processes will enhance your ability to identify potential vulnerabilities.
2. While navigating the application, intercept requests and pay close attention to sensitive functionalities. Document every request sent throughout these activities.
3. Employ creative thinking to devise methods for bypassing access control measures or otherwise disrupting application logic.
4. Consider strategies to combine any vulnerabilities you uncover with others to amplify the overall impact of the exploit.
\n
"""

TEMPLATE_INJECTION_PROMPT = """
Finding a template injection vulnerability typically involves the following steps as reference:
1. Look for opportunities where user input can be submitted to the application. Identify potential candidates for template injection that warrant further examination.
2. Detect template injection by submitting test payloads. This can include payloads meant to trigger errors or engine-specific payloads designed for the particular template engine in use.
3. If you discover an endpoint prone to template injection, establish which template engine is being utilized. This knowledge will aid you in crafting an exploit tailored to that engine.
4. Conduct research on the template engine and the programming language employed by the target, which will help inform your exploit development.
5. Aim to escalate the vulnerability to arbitrary command execution. As a proof of concept that doesn’t harm the system, you might execute a command such as `touch template_injection_by_YOUR_NAME.txt` to create a specific proof-of-concept file.
\n
"""

XXE_PROMPT = """
Finding an XML external entity (XEE) vulnerability typically involves the following steps as reference:
1. Locate entry points where you can submit XML data.
2. Assess whether these entry points are susceptible to classic or blind XXE attacks. An endpoint may indicate vulnerability to classic XXE if it returns parsed XML data in the HTTP response, while a blind XXE may not return data; in this case, consider setting up a callback listener for your tests.
3. Experiment with various test payloads to determine if the XML parser is misconfigured. For classic XXEs, check if the parser processes external entities; for blind XXEs, ensure that you can trigger outbound requests to your callback listener.
4. If the XML parser exhibits vulnerabilities to XXE attacks, attempt to exfiltrate a common system file, such as `/etc/hostname`.
5. You may also pursue the retrieval of more sensitive files, like `/etc/shadow` or `~/bash_history`.
6. If you find it challenging to exfiltrate an entire file with basic XXE payloads, explore alternative data exfiltration techniques.
7. Investigate the potential for launching a Server-Side Request Forgery (SSRF) attack via the XXE vulnerability.
\n
"""

INSECURE_DESERIALIZATION_PROMPT = """
Finding an insecure deserialization vulnerability typically involves the following steps as reference:
1. If you have access to the application’s source code, search for any deserialization functions that handle user input.
2. In the absence of source code access, look for large data structures being passed into the application. These might suggest the presence of serialized objects that have been encoded.
3. As an alternative, identify features that may deserialize user-supplied objects, such as database inputs, authentication tokens, or HTML form parameters.
4. If the serialized object includes user identity information, attempt to manipulate it to see if you can achieve authentication bypass.
5. Explore possibilities to escalate this vulnerability into a SQL injection or Remote Code Execution (RCE). Be cautious to avoid causing any damage to the application or server you are testing.
\n
"""

SSRF_PROMPT = """
Finding a server side request forgery (SSRF) vulnerability typically involves the following steps as reference:
1. Identify features within the application that may be susceptible to SSRF attacks, and make a note of your findings for future reference.
2. Set up a callback listener to detect blind SSRFs, utilizing services like Netcat or Burp's Collaborator feature.
3. Test the potentially vulnerable endpoints by providing them with common internal addresses or your callback listener's address.
4. Observe whether the server responds with information indicating an SSRF; in the case of a blind SSRF, review your server logs for requests initiated by the target server.
5. For blind SSRFs, evaluate if the behavior of the server changes when you request different hosts or ports.
6. If there are implemented SSRF protections, attempt to bypass these measures using the techniques discussed earlier.
7. Determine a strategy for escalating the SSRF for potential impact.
\n
"""

RACE_CONDITIONS_PROMPT = """
Finding a race condition vulnerability typically involves the following steps as reference:
1. Identify features in the target application that are often susceptible to race conditions, and replicate the corresponding requests.
2. Simultaneously send multiple critical requests to the server. Craft requests that should ideally be permitted only once, but might be executed multiple times.
3. Evaluate the outcomes to determine if your attack was successful, and consider running the attack multiple times to increase the likelihood of success.
4. Reflect on the potential impact of the discovered race condition.
\n
"""

SQL_INJECTION_PROMPT = """
Finding a SQL injection vulnerability typically involves the following steps as reference:
1. Map out the application’s endpoints that accept user input.
2. Insert various test payloads into these input locations to check for SQL injection vulnerabilities. If a specific endpoint does not seem susceptible to classic SQL injections, consider employing inferential techniques instead.
3. Once a vulnerability is confirmed for an endpoint, use different SQL injection queries to extract data from the database.
4. Work to escalate the issue. Identify what data can be extracted and assess whether an authentication bypass is possible. Exercise caution to avoid executing actions that could compromise the integrity of the database, such as deleting user records or altering the database structure.
\n
"""

IDOR_PROMPT = """
Finding an IDOR vulnerability typically involves the following steps as reference:
1. Set up two accounts for each role within the application, designating one as the attacker account and the other as the victim account. . IDOR vulnerabilities may be in this signup or login process. 
2. Identify features within the application that could potentially expose IDOR vulnerabilities. Focus on functionalities that return sensitive information or allow modification of user data.
3. Revisit the features identified in step 2 while using a proxy to intercept your browser’s traffic as you navigate the sensitive areas of the application.
4. With the proxy in place, capture each sensitive request and alter the IDs present in those requests. If modifying the IDs enables access to another user's information or allows data changes, you may have uncovered an IDOR.
5. If the application appears resistant to IDOR attacks, don't lose hope—this could be a chance to employ a protection-bypass technique! If the application uses encoded, hashed, or randomized IDs, experiment with decoding or predicting the IDs. Additionally, you can try providing the application with an ID that it doesn’t specifically request. Sometimes, changing the request method or file type can yield different results.
6. Stay vigilant for potential information leaks through export files, emails, and text alerts; an IDOR discovered now may result in an information leak later.
\n
"""

CSRF_PROMPT = """
Finding a CSRF vulnerability typically involves the following steps as reference::
1. Identify the state-changing actions within the application and take note of their locations and functionalities.
2. Assess these functionalities to determine if any CSRF protections are implemented. If you don’t observe any protective measures, you may have identified a vulnerability!
3. If CSRF protection mechanisms are present, attempt to bypass them using the techniques mentioned.
4. Verify the vulnerability by creating a malicious HTML page and visiting it to see whether the intended action is executed.
5. Consider strategies for effectively delivering your payload to end users.
\n
"""

CLICKJACKING_PROMPT = """
Finding a clickjacking vulnerability typically involves the following steps as reference:
1. Identify state-changing actions on the website and document their URL locations. Be sure to note those that can be executed with simple mouse clicks for further testing.
2. Review these pages for protective features such as the X-Frame-Options header, Content-Security-Policy, and SameSite session cookies. If these safeguards are absent, the page may be vulnerable.
3. Create an HTML page that frames the target page, then load this page in a browser to check if the frame is successfully rendered.
4. Verify the vulnerability by performing a simulated clickjacking attack using your own test account.
5. Develop strategic methods for delivering your payload to end users, and consider the broader implications of the vulnerability.
\n
"""

OPEN_REDIRECT_PROMPT = """
Finding an open redirect vulnerability typically involves the following steps as reference:
1. Look for URL parameters that facilitate redirects, as these may be susceptible to parameter-based open redirects.
2. Identify pages that execute referer-based redirects—these could be candidates for referer-based open redirects.
3. Conduct tests on the pages and parameters you have identified to check for open redirects.
4. If the server prevents the open redirect, explore protection bypass techniques mentioned.
5. Consider innovative ways to exploit the open redirect as part of your broader attack strategy.
\n
"""

XSS_PROMPT = """
Finding a cross site scripting (XSS) vulnerability typically involves the following steps as reference:
1. Search for opportunities where user input can be submitted within the application. If user input is stored and later used to generate a web page, test those input fields for stored XSS vulnerabilities. Additionally, if user input in a URL is echoed back in the resulting page, test for reflected and DOM-based XSS.
2. Insert various XSS payloads into the identified user input fields. Use payloads sourced from online lists, polyglot payloads, or generic test strings.
3. Verify the impact of your payloads by checking if your browser executes your JavaScript code. For blind XSS scenarios, aim to generate a request from the victim's browser to your server to confirm execution.
4. If you are unable to execute any payloads successfully, consider attempting to bypass any XSS protections that may be in place.
5. Streamline the XSS discovery process by employing automation techniques.
6. Assess the potential impact of the XSS vulnerability you have found: Who is affected? How many users might it impact? What actions could you achieve through this vulnerability? Consider whether you can escalate the attack based on your discoveries.
\n
"""


VULNERABILITY_PROMPTS = {
    VulnerabilityType.IDOR: IDOR_PROMPT,
    VulnerabilityType.CSRF: CSRF_PROMPT,
    VulnerabilityType.CLICKJACKING: CLICKJACKING_PROMPT,
    VulnerabilityType.OPEN_REDIRECT: OPEN_REDIRECT_PROMPT,
    VulnerabilityType.SOP_BYPASS: SOP_BYPASS_PROMPT,
    VulnerabilityType.SSO_BYPASS: SSO_BYPASS_PROMPT,
    VulnerabilityType.RCE: RCE_PROMPT,
    VulnerabilityType.APPLICATION_LOGIC_ERRORS: APPLICATION_LOGIC_ERRORS_AND_BROKEN_ACCESS_CONTROL_PROMPT,
    VulnerabilityType.TEMPLATE_INJECTION: TEMPLATE_INJECTION_PROMPT,
    VulnerabilityType.XXE: XXE_PROMPT,
    VulnerabilityType.INSECURE_DESERIALIZATION: INSECURE_DESERIALIZATION_PROMPT,
    VulnerabilityType.SSRF: SSRF_PROMPT,
    VulnerabilityType.RACE_CONDITIONS: RACE_CONDITIONS_PROMPT,
    VulnerabilityType.SQL_INJECTION: SQL_INJECTION_PROMPT,
    VulnerabilityType.XSS: XSS_PROMPT,
}


def get_specialized_instructions(vuln_type: str) -> str:
    try:
        enum_vuln_type = VulnerabilityType(vuln_type)
        return VULNERABILITY_PROMPTS.get(enum_vuln_type, "")
    except ValueError:
        return ""
