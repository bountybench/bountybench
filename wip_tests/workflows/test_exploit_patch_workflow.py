import os
import shutil
import unittest
from typing import Optional
from unittest.mock import MagicMock, patch

from agents.exploit_agent.exploit_agent import ExploitAgent
from agents.patch_agent.patch_agent import PatchAgent
from messages.answer_message import AnswerMessage
from messages.answer_message_interface import AnswerMessageInterface
from messages.command_message import CommandMessage
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.kali_env_resource import KaliEnvResource
from resources.setup_resource import SetupResource
from resources.utils import read_bounty_metadata, read_repo_metadata
from utils.workflow_logger import workflow_logger


class TestExploitAndPatchWorkflow(unittest.TestCase):
    def setUp(self):
        """
        Prepare the test environment using real resources (Docker, KaliEnv, etc.)
        and real ExploitAgent/PatchAgent. We only plan to mock the ExecutorAgent.
        """
        self.repo_name = "lunary"
        self.bounty_number = "0"

        self.task_repo_dir = os.path.abspath(
            os.path.join("bountybench", self.repo_name)
        )
        self.bounty_dir = os.path.join(
            self.task_repo_dir, "bounties", f"bounty_{self.bounty_number}"
        )

        # Example subfolders for exploit and patch files:
        self.exploit_files_src = os.path.join(self.bounty_dir, "exploit_files")
        self.patch_files_src = os.path.join(self.bounty_dir, "patch_files")

        # Read the metadata
        self.repo_metadata = read_repo_metadata(self.task_repo_dir)
        self.bounty_metadata = read_bounty_metadata(
            self.task_repo_dir, self.bounty_number
        )

        # Typical directory setup in the local repository
        self.files_dir = "codebase"
        self.tmp_dir = "tmp"
        self.tmp_dir_abs = os.path.join(self.task_repo_dir, self.tmp_dir)

        workflow_logger.initialize(
            workflow_name="",
            logs_dir="",
            task_repo_dir="",
            bounty_number="0",
            model_config={},
        )

        # Initialize resources
        InitFilesResource(
            task_repo_dir=self.task_repo_dir,
            files_dir_name=self.files_dir,
            tmp_dir_name=self.tmp_dir,
            exploit_files_dir_name=None,
            vulnerable_commit=self.bounty_metadata["vulnerable_commit"],
        )

        # If there's a top-level setup script:
        if os.path.exists(os.path.join(self.task_repo_dir, "setup_repo_env.sh")):
            SetupResource(
                task_level_setup=False,
                task_repo_dir=self.task_repo_dir,
                files_dir=self.files_dir,
            )

        # If there's a target host in the repo metadata:
        if self.repo_metadata.get("target_host"):
            SetupResource(
                task_level_setup=True,
                task_repo_dir=self.task_repo_dir,
                files_dir=self.files_dir,
                bounty_number=self.bounty_number,
                server_address=self.repo_metadata["target_host"],
            )

        # Docker resource
        DockerResource("DockerHelper")

        # Kali environment:
        self.kali_env = KaliEnvResource(
            "KaliEnv",
            task_repo_dir=self.task_repo_dir,
            bounty_number=self.bounty_number,
            volumes={
                self.tmp_dir_abs: {"bind": "/app", "mode": "rw"},
                "/tmp": {"bind": "/tmp", "mode": "rw"},
            },
        )

        self.tmp_exploit_files = "/tmp/exploit_files"
        self.kali_env.run_command(f"mkdir -p {self.tmp_exploit_files}")
        self.exploit_agent = ExploitAgent(
            bounty_dir=os.path.join(
                self.task_repo_dir, "bounties", f"bounty_{self.bounty_number}"
            )
        )

        self.patch_agent = PatchAgent(
            bounty_dir=os.path.join(
                self.task_repo_dir, "bounties", f"bounty_{self.bounty_number}"
            ),
            exploit_files_dir=self.tmp_exploit_files,
            use_verify_script=True,
        )
        # End of setUp

    def tearDown(self):
        """
        Clean up the exploit/patch directories in Kali after each test.
        """
        self.kali_env.run_command(f"rm -rf {self.tmp_exploit_files}")
        # Also remove any patch files if you like:
        self.kali_env.run_command(f"rm -rf /app/patch_*.sh /app/patch_*.diff")
        # Adjust as needed for your environment

    # -------------------------------------------------------------------------
    # Helper functions for creating/copying files into Kali
    # -------------------------------------------------------------------------
    def create_file_in_kali(self, filename, content, directory: Optional[str] = None):
        if directory:
            self.kali_env.run_command(f"mkdir -p {directory}")
            dest_file = f"{directory}/{filename}"
        else:
            dest_file = filename
        create_file_cmd = f"cat << 'EOF' > {dest_file}\n{content}\nEOF"
        self.kali_env.run_command(create_file_cmd)
        self.kali_env.run_command(f"chmod 755 {dest_file}")

    def copy_files_to_kali(self, src_dir, dest_dir):
        self.kali_env.run_command(f"mkdir -p {dest_dir}")
        for filename in os.listdir(src_dir):
            src_file = os.path.join(src_dir, filename)
            with open(src_file, "r", encoding="utf-8") as f:
                content = f.read()
            self.create_file_in_kali(filename, content, dest_dir)

    def copy_exploit_files_to_kali(self):
        self.copy_files_to_kali(self.exploit_files_src, self.tmp_exploit_files)

    def copy_patch_files_to_kali(self):
        self.copy_files_to_kali(self.patch_files_src, self.tmp_dir_abs)
        # Apply patches to the correct code locations
        for src, dest in self.bounty_metadata["patch"].items():
            src_file = f"{self.tmp_dir_abs}/{os.path.basename(src)}"
            dest_file = f"/app/{dest}"
            self.kali_env.run_command(f"cp {src_file} {dest_file}")

    # -------------------------------------------------------------------------
    # Test: End-to-end exploit+patch with ExecutorAgent mocked
    # -------------------------------------------------------------------------
    @patch("agents.executor_agent.executor_agent.ExecutorAgent", autospec=True)
    def test_exploit_and_patch_full_workflow(self, MockExecutorAgentClass):
        """
        Runs the entire exploit->patch workflow using real ExploitAgent & PatchAgent,
        real Docker/Kali resources, but a mocked ExecutorAgent. We create/copy the
        correct or incorrect files in the environment to simulate each step.
        """
        # 1) Prepare a single mock ExecutorAgent instance
        mock_executor_instance = MagicMock()
        MockExecutorAgentClass.return_value = mock_executor_instance

        # For simplicity, we'll have ExecutorAgent.run() always return
        # a generic CommandMessage. The "real" success/failure logic is
        # done by ExploitAgent/PatchAgent reading the presence/contents
        # of exploit/patch files in the environment.
        mock_executor_instance.run.return_value = CommandMessage("command: ls")

        # ---------------------------------------------------------------------
        # EXPLOIT PHASE
        # Step 1: no exploit file => Exploit should fail
        # ---------------------------------------------------------------------
        # message_1 = self.exploit_agent.run([CommandMessage("command: run-exploit")])
        # self.assertIsInstance(message_1, BaseMessage)
        # self.assertNotIsInstance(message_1, AnswerMessageInterface)
        # self.assertIn("No exploit script found.", message_1.message, "Step 1: Should fail with no exploit file")

        # # Step 2: create/copy *incorrect* exploit file => still fail
        # self.kali_env.run_command(f"rm -rf {self.tmp_exploit_files}")  # ensure empty
        # self.kali_env.run_command(f"mkdir -p {self.tmp_exploit_files}")
        # # Create some broken exploit.sh
        # self.create_file_in_kali("exploit.sh", "#!/bin/bash\necho 'This is a broken exploit'\nexit 1", self.tmp_exploit_files)

        # message_2 = self.exploit_agent.run([CommandMessage("command: run-exploit")])
        # self.assertIn("Exploit failed", message_2.message, "Step 2: Should fail with incorrect exploit file")

        # # Step 3: remove the broken exploit, copy the *correct* exploit files => succeed
        # self.kali_env.run_command(f"rm -rf {self.tmp_exploit_files}")
        self.copy_exploit_files_to_kali()  # copy real exploit from self.exploit_files_src
        message_3 = self.exploit_agent.run([CommandMessage("command: run-exploit")])

        # The real ExploitAgent is expected to detect a successful exploit now
        self.assertIsInstance(
            message_3,
            AnswerMessage,
            "Correct exploit => success => returns an AnswerMessage",
        )
        self.assertIn("Exploit successful.", message_3.message)

        # ---------------------------------------------------------------------
        # PATCH PHASE
        # Step 1: No patch => fails
        # ---------------------------------------------------------------------
        patch_message_1 = self.patch_agent.run([CommandMessage("command: run-patch")])
        self.assertNotIsInstance(patch_message_1, AnswerMessageInterface)
        self.assertIn(
            "No git diff detected within codebase, skipping patching.",
            patch_message_1.message,
            "Should fail with no patch",
        )

        # Step 2: Incorrect patch => still fail
        # We'll create a dummy patch file
        dummy_patch_content = (
            "#!/bin/bash\necho 'This is a dummy patch that does nothing!'"
        )
        dummy_patch_filename = "patch_dummy.sh"
        self.create_file_in_kali(dummy_patch_filename, dummy_patch_content)

        self.kali_env.run_command(f"ls")
        patch_message_2 = self.patch_agent.run([CommandMessage("command: run-patch")])
        self.assertIn(
            "patch failed", patch_message_2.message, "Should fail with incorrect patch"
        )

        # Step 3: Correct patch => success
        # First, remove the dummy patch
        self.kali_env.run_command(f"rm -f /app/{dummy_patch_filename}")
        self.copy_patch_files_to_kali()  # apply real patch files from self.patch_files_src
        patch_message_3 = self.patch_agent.run([CommandMessage("command: run-patch")])

        self.assertIsInstance(
            patch_message_3,
            AnswerMessageInterface,
            "Expect success => AnswerMessage or similar",
        )
        self.assertIn("The patch succeeded.", patch_message_3.message)

        # Finally, confirm the ExecutorAgent was indeed called (though it’s mocked)
        self.assertTrue(
            mock_executor_instance.run.called,
            "ExecutorAgent mock should have been used at least once",
        )


if __name__ == "__main__":
    unittest.main()
