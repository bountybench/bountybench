import unittest
from unittest.mock import Mock, patch
import os
from pathlib import Path

# Import the necessary modules and classes
from workflows.exploit_and_patch_workflow import main, run_exploit_phase, run_patch_phase
from agents.executor_agent.executor_agent import ExecutorAgent
from agents.exploit_agent.exploit_agent import ExploitAgent
from agents.patch_agent.patch_agent import PatchAgent
from agents.dataclasses.agent_spec import AgentConfig
from resources.kali_env_resource import KaliEnvResource
from resources.init_files_resource import InitFilesResource
from resources.setup_resource import SetupResource
from resources.docker_resource import DockerResource
from responses.command_response import CommandResponse
from responses.answer_response import AnswerResponse

class TestExploitAndPatchWorkflow(unittest.TestCase):
    def setUp(self):
        self.task_repo_dir = Path("/mock/task/repo")
        self.bounty_number = "123"
        self.config = AgentConfig(
            model="openai/gpt-4-0314",
            max_output_tokens=2000,
            max_input_tokens=6000,
            max_iterations=15,
            max_response_len=3,
            use_helm=True
        )

        # Set up real resources
        self.init_files = InitFilesResource(
            task_repo_dir=self.task_repo_dir,
            files_dir_name="codebase",
            tmp_dir_name="tmp",
            exploit_files_dir_name=None,
            vulnerable_commit="abc123"
        )
        self.setup = SetupResource(
            task_level_setup=True,
            task_repo_dir=self.task_repo_dir,
            files_dir="codebase",
            bounty_number=self.bounty_number,
            server_address="example.com"
        )
        self.kali_env = KaliEnvResource(
            "KaliEnv",
            task_repo_dir=self.task_repo_dir,
            bounty_number=self.bounty_number,
            volumes={
                str(self.task_repo_dir / "tmp"): {"bind": "/app", "mode": "rw"},
                str(self.task_repo_dir / "tmp" / "exploit_files"): {"bind": "/app/exploit_files", "mode": "rw"},
                "/tmp": {"bind": "/tmp", "mode": "rw"}
            }
        )
        self.docker = DockerResource("DockerHelper")

        # Mock ExecutorAgent
        self.executor_agent = Mock(spec=ExecutorAgent)

        # Set up real ExploitAgent and PatchAgent
        self.exploit_agent = ExploitAgent(bounty_dir=f"bounties/bounty_{self.bounty_number}")
        self.patch_agent = PatchAgent(bounty_dir=f"bounties/bounty_{self.bounty_number}", exploit_files_dir=None, use_verify_script=False)

    def create_file_in_kali(self, directory, filename, content):
        self.kali_env.run_command(f"mkdir -p {directory}")
        dest_file = f"{directory}/{filename}"
        create_file_cmd = f"cat << 'EOF' > {dest_file}\n{content}\nEOF"
        self.kali_env.run_command(create_file_cmd)
        self.kali_env.run_command(f"chmod 755 {dest_file}")

    def setup_exploit_files(self, step):
        exploit_dir = "/app/exploit_files"
        if step == 1:
            # No exploit.sh
            pass
        elif step == 2:
            # Incorrect exploit.sh
            self.create_file_in_kali(exploit_dir, "exploit.sh", "echo 'Incorrect exploit'")
        elif step == 3:
            # Correct exploit.sh
            self.create_file_in_kali(exploit_dir, "exploit.sh", "echo 'Correct exploit'; touch /tmp/exploited")

    def setup_patch_files(self, step):
        patch_dir = "/app/codebase"
        if step == 1:
            # No patch
            pass
        elif step == 2:
            # Incorrect patch (dummy file)
            self.create_file_in_kali(patch_dir, "dummy_patch.txt", "This is not a real patch")
        elif step == 3:
            # Correct patch
            self.create_file_in_kali(patch_dir, "correct_patch.diff", "--- a/vulnerable_file.py\n+++ b/vulnerable_file.py\n@@ -1,5 +1,5 @@\n-def vulnerable_function():\n+def secure_function():\n     print('This function is now secure')")

    @patch('exploit_and_patch_workflow.ExecutorAgent')
    def test_exploit_and_patch_workflow(self, MockExecutorAgent):
        MockExecutorAgent.return_value = self.executor_agent

        # Simulate exploit phase
        for step in range(1, 4):
            self.setup_exploit_files(step)
            if step < 3:
                self.executor_agent.run.return_value = CommandResponse(f"Exploit step {step} failed")
            else:
                self.executor_agent.run.return_value = AnswerResponse("Exploit successful")
            
            result = run_exploit_phase(self.executor_agent, self.exploit_agent, 1)
            
            if step < 3:
                self.assertIsNone(result)
            else:
                self.assertIsNotNone(result)

        # Simulate patch phase
        for step in range(1, 4):
            self.setup_patch_files(step)
            if step < 3:
                self.executor_agent.run.return_value = CommandResponse(f"Patch step {step} failed")
            else:
                self.executor_agent.run.return_value = AnswerResponse("Patch successful")
            
            result = run_patch_phase(self.executor_agent, self.patch_agent, 1, "Initial response")
            
            if step < 3:
                self.assertFalse(result)
            else:
                self.assertTrue(result)

        # Verify that the workflow completed successfully
        self.assertTrue(os.path.exists("/tmp/exploited"))
        self.assertTrue(os.path.exists("/app/codebase/correct_patch.diff"))

if __name__ == "__main__":
    unittest.main()