import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from phases.exploit_phase import ExploitPhase
from phases.patch_phase import PatchPhase
from resources.utils import read_writeup
from utils.logger import get_main_logger
from workflows.exploit_patch_workflow import ExploitPatchWorkflow

logger = get_main_logger(__name__)


# ---- FIXTURE FOR WORKFLOW ----
@pytest.fixture
def exploit_patch_workflow():
    """Fixture to initialize ExploitPatchWorkflow."""

    class MockExploitPatchWorkflow(ExploitPatchWorkflow):
        def _get_initial_prompt(self):
            return "Mocked Initial Prompt"

    return MockExploitPatchWorkflow(
        task_dir="test_task",
        bounty_number="12345",
        interactive=False,
        model="mock-model",
        phase_iterations=2,
    )


# ---- TESTING WORKFLOW INITIALIZATION ----
def test_exploit_patch_workflow_initialization(exploit_patch_workflow):
    """Test if ExploitPatchWorkflow initializes correctly."""
    assert exploit_patch_workflow.bounty_number == "12345"
    assert exploit_patch_workflow.task_dir == "test_task"
    assert exploit_patch_workflow.phase_iterations == 2


# ---- TESTING PHASE CREATION ----
@patch("workflows.exploit_patch_workflow.ExploitPhase")
@patch("workflows.exploit_patch_workflow.PatchPhase")
def test_create_phases(mock_patch_phase, mock_exploit_phase, exploit_patch_workflow):
    """Test that Exploit and Patch phases are created and linked correctly."""
    mock_exploit_instance = MagicMock(spec=ExploitPhase)
    mock_patch_instance = MagicMock(spec=PatchPhase)

    mock_exploit_phase.return_value = mock_exploit_instance
    mock_patch_phase.return_value = mock_patch_instance

    exploit_patch_workflow._create_phases()

    # Ensure the root phase is registered as ExploitPhase
    assert exploit_patch_workflow._root_phase == mock_exploit_instance

    # Ensure phase connection exists (ExploitPhase >> PatchPhase)
    mock_exploit_instance.__rshift__.assert_called_once_with(mock_patch_instance)


# ---- TESTING INITIAL PROMPT SELECTION ----
def test_get_initial_prompt_target_host():
    """Test correct prompt selection when target_host is present."""

    class MockExploitPatchWorkflow(ExploitPatchWorkflow):
        def __init__(self):
            self.repo_metadata = {"target_host": True}

    workflow = MockExploitPatchWorkflow()
    assert workflow._get_initial_prompt() == "TARGET_HOST_EXPLOIT_AND_PATCH_PROMPT"


def test_get_initial_prompt_no_target_host():
    """Test correct prompt selection when target_host is not present."""

    class MockExploitPatchWorkflow(ExploitPatchWorkflow):
        def __init__(self):
            self.repo_metadata = {"target_host": False}

    workflow = MockExploitPatchWorkflow()
    assert workflow._get_initial_prompt() == "EXPLOIT_AND_PATCH_PROMPT"


# ---- TESTING WORKFLOW RUN ----
@pytest.mark.asyncio
async def test_exploit_patch_workflow_run():
    """Test that the exploit-patch workflow runs correctly."""
    workflow = MagicMock(spec=ExploitPatchWorkflow)
    workflow._run_phases = AsyncMock(return_value=iter([]))

    await workflow.run()
    workflow._run_phases.assert_called_once()


# ---- TESTING FILE OPERATIONS ----
@patch("resources.utils.read_writeup")
def test_read_writeup(mock_read_writeup, exploit_patch_workflow):
    """Test if the exploit-patch workflow reads writeup correctly."""
    mock_read_writeup.return_value = "Mocked Writeup Content"

    content = read_writeup("test_task", "12345")

    assert content == "Mocked Writeup Content"
    mock_read_writeup.assert_called_once_with("test_task", "12345")


# ---- TESTING WORKFLOW ARGUMENT PARSING ----
@patch("argparse.ArgumentParser.parse_args")
def test_main_argument_parsing(mock_parse_args):
    """Test command-line argument parsing for the main function."""
    from workflows.exploit_patch_workflow import main

    mock_parse_args.return_value = MagicMock(
        task_dir="test_task",
        bounty_number="12345",
        interactive=True,
        model="test-model",
        phase_iterations=3,
    )

    asyncio.run(main())

    mock_parse_args.assert_called_once()


# ---- RUN TESTS ----
if __name__ == "__main__":
    pytest.main()
