import os
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch
import io

import pytest

from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from messages.action_messages.action_message import ActionMessage
from messages.agent_messages.agent_message import AgentMessage
from messages.agent_messages.exploit_agent_message import ExploitAgentMessage
from utils.file_utils import apply_patch_to_bounty

@pytest.fixture
def agent_config(tmp_path):
    bounty_dir = tmp_path / "bounty"
    task_dir = tmp_path / "task"
    tmp_dir = tmp_path / "tmp"
    bounty_dir.mkdir()
    task_dir.mkdir()
    tmp_dir.mkdir()
    return ExploitAgentConfig(bounty_dir=bounty_dir, task_dir=task_dir, tmp_dir=tmp_dir)


@pytest.fixture
def exploit_agent(agent_config):
    return ExploitAgent(agent_id="exploit_test", agent_config=agent_config)


@pytest.fixture
def mock_prev_message():
    return AgentMessage(agent_id="prev_agent")


@pytest.mark.asyncio
async def test_run_skips_if_no_exploit_script(exploit_agent, mock_prev_message):
    message = await exploit_agent.run([mock_prev_message])
    assert "No exploit.sh found" in message.message


@pytest.mark.asyncio
async def test_run_skips_if_no_git_changes(exploit_agent, mock_prev_message):
    script_path = exploit_agent.tmp_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with patch(
        "agents.exploit_agent.exploit_agent.git_has_changes", return_value=False
    ):
        message = await exploit_agent.run([mock_prev_message])
        assert "No changes to exploit files detected" in message.message


@pytest.mark.asyncio
async def test_validate_exploit_script_success_flow(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    
    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch("agents.exploit_agent.exploit_agent.apply_patch_to_bounty", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit has meet all success criteria." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_verify_fails(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    
    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch("agents.exploit_agent.exploit_agent.apply_patch_to_bounty", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit verification failed after patch." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_raises_and_sets_failure(
    exploit_agent, mock_prev_message
):
    script_path = exploit_agent.tmp_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with (
        patch("agents.exploit_agent.exploit_agent.git_has_changes", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch.object(
            exploit_agent, "validate_exploit_script", side_effect=Exception("Crash")
        ),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        with pytest.raises(Exception):
            await exploit_agent.run([mock_prev_message])


@pytest.mark.asyncio
async def test_run_command_async_error(exploit_agent):
    exploit_agent.resources = MagicMock()
    exploit_agent.resources.docker.run = AsyncMock(
        return_value=ActionMessage(resource_id="docker", message="issue")
    )

    verify_path = exploit_agent.bounty_dir / "verify.sh"
    verify_path.write_text("#!/bin/bash\necho verify")
    verify_path.chmod(0o755)

    with (
        patch(
            "agents.exploit_agent.exploit_agent.run_command_async",
            side_effect=Exception("fail"),
        ),
        patch.object(exploit_agent, "restart_resources", return_value=True),
        patch("sys.stdout", new=io.StringIO()),
        patch("sys.stderr", new=io.StringIO())
    ):
        result = await exploit_agent._run_exploit_verify()
        assert result is None


def test_apply_patch_to_bounty_success(agent_config):
    metadata = {"patch": {"source.py": "dest.py"}}
    source = agent_config.bounty_dir / "source.py"
    dest = agent_config.task_dir / "dest.py"
    source.write_text("patched code")
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is True
    assert dest.exists()


def test_apply_patch_to_bounty_failure(agent_config):
    metadata = {"patch": {"missing.py": "dest.py"}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is False
    

def test_apply_patch_to_bounty_no_metadata_file(agent_config):
    with pytest.raises(RuntimeError, match="No bounty metadata file found."):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_apply_patch_to_bounty_invalid_json(agent_config):
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text("not json")

    result = apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)
    assert result is False


def test_apply_patch_to_bounty_no_patch_key(agent_config):
    metadata = {"something_else": {}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    with pytest.raises(RuntimeError, match="Patch required for bounty. No patch found."):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_restart_resources_order(exploit_agent):
    restart_calls = []

    mock_repo = MagicMock()
    mock_repo.resource_id = "repo_setup"
    mock_bounty = MagicMock()
    mock_bounty.resource_id = "bounty_setup"

    exploit_agent.resources.repo_setup = mock_repo
    exploit_agent.resources.bounty_setup = mock_bounty
    exploit_agent.resources.has_bound = lambda x: True

    def mock_restart(r):
        restart_calls.append(r.resource_id)
        return True

    with patch.object(exploit_agent, "_restart_resource", side_effect=mock_restart):
        exploit_agent.restart_resources()

    assert restart_calls == ["repo_setup", "bounty_setup"]


def test_serialization_roundtrip(agent_config):
    agent = ExploitAgent(agent_id="ser_test", agent_config=agent_config)
    data = agent.to_dict()
    restored = ExploitAgent.from_dict(data)
    assert restored.bounty_dir == agent.bounty_dir
