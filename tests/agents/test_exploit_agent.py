import os
import sys
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch
import io
import shutil
from contextlib import redirect_stdout, redirect_stderr

import pytest

from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from messages.action_messages.action_message import ActionMessage
from messages.agent_messages.agent_message import AgentMessage
from messages.agent_messages.exploit_agent_message import ExploitAgentMessage
from utils.file_utils import apply_patch_to_bounty

@pytest.fixture
def agent_config(tmp_path):
    bounty_dir = tmp_path / "bounty"
    task_dir = tmp_path / "task"
    tmp_dir = tmp_path / "tmp"
    bounty_dir.mkdir()
    task_dir.mkdir()
    tmp_dir.mkdir()
    return ExploitAgentConfig(bounty_dir=bounty_dir, task_dir=task_dir, tmp_dir=tmp_dir)


@pytest.fixture
def exploit_agent(agent_config):
    return ExploitAgent(agent_id="exploit_test", agent_config=agent_config)


@pytest.fixture
def mock_prev_message():
    return AgentMessage(agent_id="prev_agent")


@pytest.mark.asyncio
async def test_run_skips_if_no_exploit_script(exploit_agent, mock_prev_message):
    message = await exploit_agent.run([mock_prev_message])
    assert "No exploit.sh found" in message.message


@pytest.mark.asyncio
async def test_run_skips_if_no_git_changes(exploit_agent, mock_prev_message):
    script_path = exploit_agent.exploit_files_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with patch(
        "agents.exploit_agent.exploit_agent.git_has_changes", return_value=False
    ):
        message = await exploit_agent.run([mock_prev_message])
        assert "No changes to exploit files detected" in message.message


@pytest.mark.asyncio
async def test_validate_exploit_script_success_flow(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    
    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch("agents.exploit_agent.exploit_agent.apply_patch_to_bounty", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit has meet all success criteria." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_verify_fails(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    
    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch("agents.exploit_agent.exploit_agent.apply_patch_to_bounty", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit verification failed after patch." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_raises_and_sets_failure(
    exploit_agent, mock_prev_message
):
    script_path = exploit_agent.exploit_files_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with (
        patch("agents.exploit_agent.exploit_agent.git_has_changes", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch.object(
            exploit_agent, "validate_exploit_script", side_effect=Exception("Crash")
        ),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        with pytest.raises(Exception):
            await exploit_agent.run([mock_prev_message])


@pytest.fixture
def null_streams():
    """A fixture to nullify stdout and stderr during test execution."""
    class NullStream:
        def write(self, *args, **kwargs):
            pass
        def flush(self, *args, **kwargs):
            pass
    
    real_stdout = sys.stdout
    real_stderr = sys.stderr
    
    sys.stdout = NullStream()
    sys.stderr = NullStream()
    
    yield
    
    sys.stdout = real_stdout
    sys.stderr = real_stderr

@pytest.mark.asyncio
async def test_run_command_async_error(exploit_agent, null_streams):
    """Test _run_exploit_verify with a failing run_command_async."""
    # Setup the mocks
    exploit_agent.resources = MagicMock()
    exploit_agent.resources.docker.run = AsyncMock(
        return_value=ActionMessage(resource_id="docker", message="issue")
    )
    
    # Mock the resource_id for deterministic script paths
    exploit_agent.resources.docker.resource_id = "test_docker"
    
    # Create folders needed
    exploit_agent.tmp_dir.mkdir(exist_ok=True)
    exploit_agent.task_codebase.mkdir(exist_ok=True)
    
    # Create verify script
    verify_path = exploit_agent.bounty_dir / "verify.sh"
    verify_path.write_text("#!/bin/bash\necho verify")
    verify_path.chmod(0o755)
    
    # Create run_exploit.sh script
    script_path = exploit_agent.tmp_dir / "run_exploit.sh"
    script_path.write_text("#!/bin/bash\necho test")
    script_path.chmod(0o755)
    
    # Patch the necessary functions
    with (
        patch(
            "agents.exploit_agent.exploit_agent.run_command_async",
            side_effect=Exception("fail"),
        ),
        patch.object(exploit_agent, "restart_resources", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_clean"),  # Mock git_clean to prevent filesystem operations
        patch("builtins.open", new_callable=MagicMock),  # Mock file operations
    ):
        # Run the test - the null_streams fixture handles stdout/stderr
        result = await exploit_agent._run_exploit_verify()
        assert result is None


def test_apply_patch_to_bounty_success(agent_config):
    metadata = {"patch": {"source.py": "dest.py"}}
    source = agent_config.bounty_dir / "source.py"
    dest = agent_config.task_dir / "dest.py"
    source.write_text("patched code")
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is True
    assert dest.exists()


def test_apply_patch_to_bounty_failure(agent_config):
    metadata = {"patch": {"missing.py": "dest.py"}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is False
    

def test_apply_patch_to_bounty_no_metadata_file(agent_config):
    with pytest.raises(RuntimeError, match="No bounty metadata file found."):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_apply_patch_to_bounty_invalid_json(agent_config):
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text("not json")

    result = apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)
    assert result is False


def test_apply_patch_to_bounty_no_patch_key(agent_config):
    metadata = {"something_else": {}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    with pytest.raises(RuntimeError, match="Patch required for bounty. No patch found."):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_restart_resources_order(exploit_agent):
    restart_calls = []

    mock_repo = MagicMock()
    mock_repo.resource_id = "repo_setup"
    mock_bounty = MagicMock()
    mock_bounty.resource_id = "bounty_setup"

    exploit_agent.resources.repo_setup = mock_repo
    exploit_agent.resources.bounty_setup = mock_bounty
    exploit_agent.resources.has_bound = lambda x: True

    def mock_restart(r):
        restart_calls.append(r.resource_id)
        return True

    with patch.object(exploit_agent, "_restart_resource", side_effect=mock_restart):
        exploit_agent.restart_resources()

    assert restart_calls == ["repo_setup", "bounty_setup"]


def test_serialization_roundtrip(agent_config):
    agent = ExploitAgent(agent_id="ser_test", agent_config=agent_config)
    data = agent.to_dict()
    restored = ExploitAgent.from_dict(data)
    assert restored.bounty_dir == agent.bounty_dir


def test_verify_file_directories_created(exploit_agent):
    """Test that verify_files_dir and verify_script paths are correctly set."""
    assert exploit_agent.verify_files_dir == exploit_agent.tmp_dir / "verify_files"
    assert exploit_agent.verify_script == exploit_agent.verify_files_dir / "verify.sh"


def test_remove_verify_files(exploit_agent):
    """Test that _remove_verify_files removes directory if it exists."""
    # Create the directory
    verify_dir = exploit_agent.verify_files_dir
    verify_dir.mkdir(parents=True, exist_ok=True)
    test_file = verify_dir / "test.txt"
    test_file.write_text("test content")
    
    # Verify directory exists before removal
    assert verify_dir.exists()
    assert test_file.exists()
    
    # Remove the directory
    exploit_agent._remove_verify_files(verify_dir)
    
    # Verify directory no longer exists
    assert not verify_dir.exists()
    assert not test_file.exists()


def test_copy_verify_files(exploit_agent):
    """Test that _copy_verify_files copies directory contents correctly."""
    # Create source directory with test files
    source_dir = exploit_agent.bounty_dir / "verify_files"
    source_dir.mkdir(parents=True, exist_ok=True)
    source_file = source_dir / "test.txt"
    source_file.write_text("test content")
    source_script = source_dir / "verify.sh"
    source_script.write_text("#!/bin/bash\necho test")
    source_script.chmod(0o755)
    
    # Create destination directory
    dest_dir = exploit_agent.verify_files_dir
    
    # Copy the files
    exploit_agent._copy_verify_files(source_dir, dest_dir)
    
    # Verify files were copied correctly
    assert dest_dir.exists()
    assert (dest_dir / "test.txt").exists()
    assert (dest_dir / "test.txt").read_text() == "test content"
    assert (dest_dir / "verify.sh").exists()
    assert (dest_dir / "verify.sh").read_text() == "#!/bin/bash\necho test"


def test_reset_verify_files(exploit_agent):
    """Test that reset_verify_files removes existing directory and copies from source."""
    # Create original verify_files directory
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    orig_dir.mkdir(parents=True, exist_ok=True)
    orig_file = orig_dir / "verify.sh"
    orig_file.write_text("#!/bin/bash\necho original")
    orig_file.chmod(0o755)
    
    # Create existing verify_files directory with different content
    verify_dir = exploit_agent.verify_files_dir
    verify_dir.mkdir(parents=True, exist_ok=True)
    verify_file = verify_dir / "verify.sh"
    verify_file.write_text("#!/bin/bash\necho old")
    verify_file.chmod(0o755)
    
    # Reset verify files
    exploit_agent.reset_verify_files()
    
    # Verify files were reset correctly
    assert verify_dir.exists()
    assert verify_file.exists()
    assert verify_file.read_text() == "#!/bin/bash\necho original"


def test_reset_verify_files_not_exists(exploit_agent):
    """Test that reset_verify_files raises exception when directory doesn't exist."""
    # Ensure verify_files directory doesn't exist
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    if orig_dir.exists():
        shutil.rmtree(orig_dir)
    
    # Verify exception is raised
    with pytest.raises(Exception, match=f"Verify files directory not found at {orig_dir}"):
        exploit_agent.reset_verify_files()


@pytest.mark.asyncio
async def test_validate_exploit_script_with_verify_files(exploit_agent):
    """Test that validate_exploit_script uses the new verify files directory."""
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    
    # Create verify files directory
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    orig_dir.mkdir(parents=True, exist_ok=True)
    orig_file = orig_dir / "verify.sh"
    orig_file.write_text("#!/bin/bash\necho verify")
    orig_file.chmod(0o755)
    
    mock_run_command = AsyncMock()
    mock_run_command.return_value.returncode = 0
    
    with (
        patch("agents.exploit_agent.exploit_agent.run_command_async", mock_run_command),
        patch("agents.exploit_agent.exploit_agent.apply_patch_to_bounty", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
        patch.object(exploit_agent, "reset_verify_files"),
    ):
        await exploit_agent.validate_exploit_script()
        
        # Verify reset_verify_files was called
        exploit_agent.reset_verify_files.assert_called_once()
        
        # Verify run_command_async was called with correct directory
        calls = mock_run_command.call_args_list
        assert len(calls) > 0
        
        # Find the call for verify.sh
        verify_call = next((call for call in calls if call[0][0] == "bash verify.sh"), None)
        assert verify_call is not None
        assert verify_call[1]["work_dir"] == exploit_agent.verify_files_dir
