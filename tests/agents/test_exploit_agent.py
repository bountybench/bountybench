import os
import shutil
import subprocess
from pathlib import Path
from unittest.mock import patch

import pytest

from agents.agent_manager import AgentManager
from agents.exploit_agent.exploit_agent import ExploitAgentConfig, ExploitAgent
from messages.action_messages.action_message import ActionMessage
from messages.agent_messages.exploit_agent_message import ExploitAgentMessage
from tests.agents.agent_test_utils import EnvPath
from tests.agents.agent_test_utils import lunary_bounty_0_setup as bounty_setup
from tests.agents.agent_test_utils import write_to_file_and_make_executable


def mock_exploit_agent_message():
    def mock_init(self, agent_id, message, prev, success=None, exploit_files_dir=None):
        self._message = message

    return patch.object(ExploitAgentMessage, "__init__", mock_init)


def mock_restart_resource():
    return patch.object(ExploitAgent, "_restart_resource")


@pytest.fixture(scope="module")
def exploit_agent(bounty_setup):
    env_path: EnvPath = bounty_setup
    # Initialize agent
    agent_manager = AgentManager(workflow_id="1")
    exploit_config = ExploitAgentConfig(
        bounty_dir=env_path.BOUNTY_DIR_FROM_TASK_DIR,
        task_dir=env_path.TASK_DIR,
    )
    agent = agent_manager.create_agent(
        "test_exploit_agent", ExploitAgent, exploit_config
    )

    # Only mock restart_resource - no need to mock ExploitAgentMessage
    mock = mock_restart_resource()
    mock.start()

    yield agent

    mock.stop()

    # revert any commits the tests made in env
    subprocess.run(["git", "reset", "--hard", "origin/main"], cwd=env_path.TASK_DIR)


@pytest.fixture(scope="module")
def execute_fixture(bounty_setup, exploit_agent):
    """
    Should be run if using execute function.
    """
    env_path: EnvPath = bounty_setup

    exploit_script_dir_path = Path(env_path.TMP_EXPLOIT_SCRIPT_DIR)
    write_to_file_and_make_executable(
        script_path=exploit_script_dir_path,
        exit_code=0,
    )
    yield


@pytest.fixture(scope="function")
def git_exploit_agent():
    fake_tmp_dir = Path("/tmp/test_exploit_agent_git")
    fake_tmp_dir.mkdir(parents=True, exist_ok=True)

    with patch.object(ExploitAgent, "__init__", lambda x: None):
        mock_exploit_agent = ExploitAgent()
        mock_exploit_agent.tmp_exploits_dir = fake_tmp_dir
        yield mock_exploit_agent, fake_tmp_dir

    shutil.rmtree(fake_tmp_dir)


@pytest.fixture(scope="function")
def store_exploit_agent():
    fake_tmp_dir = Path("/tmp/test_exploit_agent_tmp_exploits_dir")
    exploits_dir = Path("/tmp/test_exploit_agent_exploits_dir")

    fake_tmp_dir.mkdir(parents=True, exist_ok=True)
    (fake_tmp_dir / "codebase").mkdir(parents=True, exist_ok=True)
    (fake_tmp_dir / "mysterious_exploit").mkdir(parents=True, exist_ok=True)
    subprocess.run(["touch", str(fake_tmp_dir / "hi.txt")])

    mock_time = patch("time.strftime", return_value="0")

    mock_time.start()
    with patch.object(ExploitAgent, "__init__", lambda x: None):
        mock_exploit_agent = ExploitAgent()
        mock_exploit_agent.tmp_exploits_dir = fake_tmp_dir
        mock_exploit_agent.exploits_dir = exploits_dir
        store_exploits_dir = Path(f"{exploits_dir}-0")
        yield mock_exploit_agent, fake_tmp_dir, store_exploits_dir, exploits_dir

    mock_time.stop()
    if fake_tmp_dir.exists():
        shutil.rmtree(fake_tmp_dir)
    if exploits_dir.exists():
        shutil.rmtree(exploits_dir)
    if store_exploits_dir.exists():
        shutil.rmtree(store_exploits_dir)

def get_git_status(tmp_dir):
    return subprocess.run(
        ['git', '--git-dir=.git', '--work-tree=.', 'status', '--porcelain'],
        cwd=tmp_dir,
        capture_output=True,
        text=True
    ).stdout

def test_init_git_repo(git_exploit_agent):
    exploit_agent, tmp_dir = git_exploit_agent
    git_file_dir = tmp_dir / ".git"
    git_ignore_dir = tmp_dir / ".gitignore"

    assert not git_file_dir.exists()
    assert not git_ignore_dir.exists()

    exploit_agent._init_git_repo()

    assert git_file_dir.exists()
    assert git_ignore_dir.exists()

    result = get_git_status(tmp_dir)

    # result should be empty (otherwise commit failed)
    assert not result

    # do it again and make sure everything still exists
    exploit_agent._init_git_repo()
    result = get_git_status(tmp_dir)

    assert git_file_dir.exists()
    assert git_ignore_dir.exists()
    assert not result

    

def test_has_changes(git_exploit_agent):
    exploit_agent, tmp_dir = git_exploit_agent
    exploit_agent._init_git_repo()

    tmp_file = tmp_dir / "hi.txt"
    assert not exploit_agent._has_changes()

    subprocess.run(["touch", str(tmp_file)])
    assert exploit_agent._has_changes()

    subprocess.run(["rm", str(tmp_file)])
    assert not exploit_agent._has_changes()
    pass

def test_commit_changes(git_exploit_agent):
    exploit_agent, tmp_dir = git_exploit_agent
    exploit_agent._init_git_repo()

    result = get_git_status(tmp_dir)
    assert not result

    tmp_file = tmp_dir / "hi.txt"
    subprocess.run(["touch", str(tmp_file)])

    result = get_git_status(tmp_dir)
    assert result

    exploit_agent._commit_changes()
    result = get_git_status(tmp_dir)
    assert not result
    assert tmp_file.exists()

def test_clean_untracked(git_exploit_agent):
    exploit_agent, tmp_dir = git_exploit_agent

    with patch("logging.Logger.error") as mock_logger_error:
        exploit_agent._clean_untracked()
        mock_logger_error.assert_called_with("Failed to clean untracked files")

    exploit_agent._init_git_repo()
    tmp_file1 = tmp_dir / "hi.txt"
    tmp_file2 = tmp_dir / "bye.txt"

    subprocess.run(["touch", str(tmp_file1)])
    subprocess.run(["git", "add", "."], cwd=str(tmp_dir))
    subprocess.run(["git", "commit", "-m", "test"], cwd=str(tmp_dir))
    tmp_file1.write_text("hi")
    subprocess.run(["touch", str(tmp_file2)])

    exploit_agent._clean_untracked()
    assert tmp_file1.exists()
    assert "hi" in tmp_file1.read_text()
    assert not tmp_file2.exists()

@pytest.mark.asyncio
async def test_run_exploit(bounty_setup, exploit_agent):
    env_path: EnvPath = bounty_setup
    agent = exploit_agent
    exploit_script_dir = Path(env_path.TMP_EXPLOIT_SCRIPT_DIR)
    write_to_file_and_make_executable(
        script_path=exploit_script_dir,
        exit_code=1,
    )
    exploit_result = await agent.run_exploit()
    assert exploit_result.additional_metadata['exit_code'] == 1

    write_to_file_and_make_executable(
        script_path=exploit_script_dir,
        exit_code=0,
    )
    exploit_result = await agent.run_exploit()
    assert exploit_result.additional_metadata['exit_code'] == 0

    write_to_file_and_make_executable(
        script_path=exploit_script_dir,
        exit_code=2,
    )
    exploit_result = await agent.run_exploit()
    assert exploit_result.additional_metadata['exit_code'] == 2

def test_store_exploit_success(store_exploit_agent):
    exploit_agent, tmp_exploits_dir, exploits_dir, _ = store_exploit_agent
    result = exploit_agent._store_exploit()

    assert result in str(exploits_dir)
    assert exploits_dir.exists()
    assert (exploits_dir / "hi.txt").exists()
    assert (exploits_dir / "mysterious_exploit").exists()
    assert not (exploits_dir / "codebase").exists()


def test_store_exploit_warns(store_exploit_agent):
    exploit_agent, tmp_exploits_dir, exploits_dir, _ = store_exploit_agent

    shutil.rmtree(tmp_exploits_dir)
    with patch("logging.Logger.warning") as mock_logger_error:
        result = exploit_agent._store_exploit()
        mock_logger_error.assert_called_with("No exploits directory found to move.")

    tmp_exploits_dir.mkdir(parents=True, exist_ok=True)
    with patch("logging.Logger.warning") as mock_logger_error:
        result = exploit_agent._store_exploit()
        mock_logger_error.assert_called_with(
            "Exploits directory is empty. No files to move."
        )

    assert result is None
    assert not exploits_dir.exists()


def test_store_exploit_exception(store_exploit_agent):
    exploit_agent, tmp_exploits_dir, exploits_dir, _ = store_exploit_agent

    exploits_dir.mkdir(parents=True, exist_ok=True)
    with patch("logging.Logger.error") as mock_logger_error:
        result = exploit_agent._store_exploit()
        mock_logger_error.assert_called_with(
            f"Failed to move exploits directory: [Errno 17] File exists: '{str(exploits_dir)}'"
        )

    assert result is None


def test_cleanup(store_exploit_agent):
    exploit_agent, _, _, exploits_dir = store_exploit_agent
    exploits_dir.mkdir(parents=True, exist_ok=True)
    exploit_agent.cleanup()
    assert not exploits_dir.exists()

@pytest.mark.asyncio
async def test_execute_exit_code_0_copy_fail(bounty_setup, exploit_agent, execute_fixture):
    env_path: EnvPath = bounty_setup
    exploit_agent: ExploitAgent = exploit_agent

    exploit_script_dir_path = Path(env_path.TMP_EXPLOIT_SCRIPT_DIR)
    write_to_file_and_make_executable(
        script_path=exploit_script_dir_path,
        exit_code=0,
    )

    exploit_agent_message = ExploitAgentMessage(agent_id="exploit_agent", message=None)

    with patch.object(ExploitAgent, "_store_exploit", return_value=False):
        await exploit_agent.execute(exploit_agent_message=exploit_agent_message)

    assert "error copying" in exploit_agent_message.message.lower()

@pytest.mark.asyncio
async def test_execute_exit_code_0_copy_success(bounty_setup, exploit_agent, execute_fixture):
    env_path: EnvPath = bounty_setup
    exploit_agent: ExploitAgent = exploit_agent

    exploit_script_dir_path = Path(env_path.TMP_EXPLOIT_SCRIPT_DIR)
    write_to_file_and_make_executable(
        script_path=exploit_script_dir_path,
        exit_code=0,
    )
    
    # Mock the docker output that would be returned by run_exploit
    mock_docker_output = ActionMessage(
        resource_id="test-resource",
        message="Requesting exploit execution",
        additional_metadata={
            "docker_image": "test-image",
            "command": "bash exploit.sh",
            "exit_code": 0,
            "output": "",
            "success": True,
        }
    )
    
    # We need to patch both _store_exploit AND run_exploit
    
    exploit_agent_message = ExploitAgentMessage(agent_id="exploit_agent", message=None)

    with patch.object(ExploitAgent, "_store_exploit", return_value="/path/to/exploit"):
        with patch.object(ExploitAgent, "run_exploit", return_value=mock_docker_output):
            # Also patch restart_resources to avoid actual resource restarts in tests
            with patch.object(ExploitAgent, "restart_resources"):
                await exploit_agent.execute(exploit_agent_message)
    
    
    assert "exploit executed successfully" in exploit_agent_message.message.lower()

@pytest.mark.asyncio
async def test_execute_exit_code_1(bounty_setup, exploit_agent, execute_fixture):
    env_path: EnvPath = bounty_setup
    exploit_agent: ExploitAgent = exploit_agent

    exploit_script_dir_path = Path(env_path.TMP_EXPLOIT_SCRIPT_DIR)
    write_to_file_and_make_executable(
        script_path=exploit_script_dir_path,
        exit_code=1,
    )
    
    exploit_agent_message = ExploitAgentMessage(agent_id="exploit_agent", message=None)

    with patch.object(ExploitAgent, "_store_exploit", return_value=True):
        await exploit_agent.execute(exploit_agent_message)
    assert "exit code: 1" in exploit_agent_message.message.lower() and "exploit failed" in exploit_agent_message.message.lower()

@pytest.mark.asyncio
async def test_execute_exit_code_2(bounty_setup, exploit_agent, execute_fixture):
    env_path: EnvPath = bounty_setup
    exploit_agent: ExploitAgent = exploit_agent

    exploit_script_dir_path = Path(env_path.TMP_EXPLOIT_SCRIPT_DIR)
    write_to_file_and_make_executable(
        script_path=exploit_script_dir_path,
        exit_code=2,
    )

    exploit_agent_message = ExploitAgentMessage(agent_id="exploit_agent", message=None)

    with patch.object(ExploitAgent, "_store_exploit", return_value=True):
        await exploit_agent.execute(exploit_agent_message)

    assert "exit code: 2" in exploit_agent_message.message.lower() and "exploit failed" in exploit_agent_message.message.lower()

@pytest.mark.asyncio
async def test_execute_restart_resources_failed(bounty_setup, exploit_agent):
    env_path: EnvPath = bounty_setup
    exploit_agent: ExploitAgent = exploit_agent

    def mock_restart_resources(self):
        raise Exception
    
    exploit_agent_message = ExploitAgentMessage(agent_id="exploit_agent", message=None)

    with patch.object(ExploitAgent, "_restart_resource", mock_restart_resources):
        await exploit_agent.execute(exploit_agent_message)

    assert "error during exploit execution" in exploit_agent_message.message.lower()

