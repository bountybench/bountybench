import io
import os
import shutil
import sys
from contextlib import redirect_stderr, redirect_stdout
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from messages.action_messages.action_message import ActionMessage
from messages.agent_messages.agent_message import AgentMessage
from messages.agent_messages.exploit_agent_message import ExploitAgentMessage
from utils.file_utils import apply_patch_to_bounty


@pytest.fixture
def agent_config(tmp_path):
    bounty_dir = tmp_path / "bounty"
    task_dir = tmp_path / "task"
    tmp_dir = tmp_path / "tmp"
    bounty_dir.mkdir()
    task_dir.mkdir()
    tmp_dir.mkdir()
    return ExploitAgentConfig(bounty_dir=bounty_dir, task_dir=task_dir, tmp_dir=tmp_dir)


@pytest.fixture
def exploit_agent(agent_config):
    return ExploitAgent(agent_id="exploit_test", agent_config=agent_config)


@pytest.fixture
def mock_prev_message():
    return AgentMessage(agent_id="prev_agent")


@pytest.mark.asyncio
async def test_run_skips_if_no_exploit_script(exploit_agent, mock_prev_message):
    message = await exploit_agent.run([mock_prev_message])
    assert "No exploit.sh found" in message.message


@pytest.mark.asyncio
async def test_run_skips_if_no_git_changes(exploit_agent, mock_prev_message):
    script_path = exploit_agent.exploit_files_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with patch(
        "agents.exploit_agent.exploit_agent.git_has_changes", return_value=False
    ):
        message = await exploit_agent.run([mock_prev_message])
        assert "No changes to exploit files detected" in message.message


@pytest.mark.asyncio
async def test_validate_exploit_script_success_flow(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit has meet all success criteria." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_verify_fails(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit verification failed after patch." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_raises_and_sets_failure(
    exploit_agent, mock_prev_message
):
    script_path = exploit_agent.exploit_files_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with (
        patch("agents.exploit_agent.exploit_agent.git_has_changes", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch.object(
            exploit_agent, "validate_exploit_script", side_effect=Exception("Crash")
        ),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        with pytest.raises(Exception):
            await exploit_agent.run([mock_prev_message])


@pytest.fixture
def null_streams():
    """A fixture to nullify stdout and stderr during test execution."""

    class NullStream:
        def write(self, *args, **kwargs):
            pass

        def flush(self, *args, **kwargs):
            pass

    real_stdout = sys.stdout
    real_stderr = sys.stderr

    sys.stdout = NullStream()
    sys.stderr = NullStream()

    yield

    sys.stdout = real_stdout
    sys.stderr = real_stderr


@pytest.mark.asyncio
async def test_run_command_async_error(exploit_agent, null_streams):
    """Test _run_exploit_verify with a failing run_command_async."""
    # Setup the mocks
    exploit_agent.resources = MagicMock()
    exploit_agent.resources.docker.run = AsyncMock(
        return_value=ActionMessage(resource_id="docker", message="issue")
    )

    # Mock the resource_id for deterministic script paths
    exploit_agent.resources.docker.resource_id = "test_docker"

    # Create folders needed
    exploit_agent.tmp_dir.mkdir(exist_ok=True)
    exploit_agent.task_codebase.mkdir(exist_ok=True)

    # Create verify script
    exploit_agent.verify_files_dir.mkdir(exist_ok=True)
    exploit_agent.verify_files_dir.write_text("#!/bin/bash\necho verify")
    exploit_agent.verify_files_dir.chmod(0o755)

    # Create run_exploit.sh script
    script_path = exploit_agent.tmp_dir / "exploit_files" / "run_exploit.sh"
    script_path.write_text("#!/bin/bash\necho test")
    script_path.chmod(0o755)

    # Patch the necessary functions
    with (
        patch(
            "agents.exploit_agent.exploit_agent.run_command_async",
            side_effect=Exception("fail"),
        ),
        patch.object(exploit_agent, "restart_resources", return_value=True),
        patch(
            "agents.exploit_agent.exploit_agent.git_clean"
        ),  # Mock git_clean to prevent filesystem operations
        patch("builtins.open", new_callable=MagicMock),  # Mock file operations
    ):
        # Run the test - the null_streams fixture handles stdout/stderr
        result = await exploit_agent._run_exploit_verify()
        assert result is None


def test_apply_patch_to_bounty_success(agent_config):
    metadata = {"patch": {"source.py": "dest.py"}}
    source = agent_config.bounty_dir / "source.py"
    dest = agent_config.task_dir / "dest.py"
    source.write_text("patched code")
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is True
    assert dest.exists()


def test_apply_patch_to_bounty_failure(agent_config):
    metadata = {"patch": {"missing.py": "dest.py"}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert (
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is False
    )


def test_apply_patch_to_bounty_no_metadata_file(agent_config):
    with pytest.raises(RuntimeError, match="No bounty metadata file found."):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_apply_patch_to_bounty_invalid_json(agent_config):
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text("not json")

    result = apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)
    assert result is False


def test_apply_patch_to_bounty_no_patch_key(agent_config):
    metadata = {"something_else": {}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    with pytest.raises(
        RuntimeError, match="Patch required for bounty. No patch found."
    ):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_restart_resources_order(exploit_agent):
    restart_calls = []

    mock_repo = MagicMock()
    mock_repo.resource_id = "repo_setup"
    mock_bounty = MagicMock()
    mock_bounty.resource_id = "bounty_setup"

    exploit_agent.resources.repo_setup = mock_repo
    exploit_agent.resources.bounty_setup = mock_bounty
    exploit_agent.resources.has_bound = lambda x: True

    def mock_restart(r):
        restart_calls.append(r.resource_id)
        return True

    with patch.object(exploit_agent, "_restart_resource", side_effect=mock_restart):
        exploit_agent.restart_resources()

    assert restart_calls == ["repo_setup", "bounty_setup"]


def test_serialization_roundtrip(agent_config):
    agent = ExploitAgent(agent_id="ser_test", agent_config=agent_config)
    data = agent.to_dict()
    restored = ExploitAgent.from_dict(data)
    assert restored.bounty_dir == agent.bounty_dir


@pytest.mark.asyncio
async def test_validate_exploit_script_patching_both_directories(exploit_agent):
    """Test that code continues only if both patching locations succeed (AND logic)."""
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")

    # Create tmp_codebase directory
    exploit_agent.tmp_codebase.mkdir(parents=True, exist_ok=True)

    # Test four scenarios with different mock return values for apply_patch_to_bounty
    test_scenarios = [
        # Scenario 1: both succeed - should proceed
        [True, True],
        # Scenario 2: task_dir succeeds, tmp_dir fails - should fail
        [True, False],
        # Scenario 3: task_dir fails, tmp_dir succeeds - should fail
        [False, True],
        # Scenario 4: both fail - should fail
        [False, False],
    ]

    # Test success scenario (both patching attempts succeed)
    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            side_effect=test_scenarios[0],
        ),
        patch("agents.exploit_agent.exploit_agent.git_commit") as mock_git_commit,
        patch("agents.exploit_agent.exploit_agent.git_reset") as mock_git_reset,
    ):
        # Reset step history
        exploit_agent.step_history = []
        await exploit_agent.validate_exploit_script()

        # Verify both were reset in the finally block
        git_reset_calls = mock_git_reset.call_args_list
        assert len(git_reset_calls) == 2
        assert git_reset_calls[0][0][0] == exploit_agent.task_codebase
        assert git_reset_calls[1][0][0] == exploit_agent.tmp_codebase

        # When both patches succeed, validation should proceed successfully
        assert "Applied patch to the vulnerability." in "\n".join(
            exploit_agent.step_history
        )
        assert "Exploit has meet all success criteria." in "\n".join(
            exploit_agent.step_history
        )

    # Test the three failure scenarios (when at least one patch fails)
    for scenario in test_scenarios[1:]:  # Test all failure scenarios
        with (
            patch.object(
                exploit_agent, "_run_exploit_verify", side_effect=[0]
            ),  # Only called once before patch
            patch(
                "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
                side_effect=scenario,
            ),
            patch("agents.exploit_agent.exploit_agent.git_reset") as mock_git_reset,
        ):
            # Reset step history
            exploit_agent.step_history = []
            await exploit_agent.validate_exploit_script()

            # Check if the failure message was logged
            assert "Failed to apply exploit patch." in "\n".join(
                exploit_agent.step_history
            )
            # Verify exploit verification was NOT run after failed patching
            assert exploit_agent._run_exploit_verify.call_count == 1


def test_verify_file_directories_created(exploit_agent):
    """Test that verify_files_dir and verify_script paths are correctly set."""
    assert exploit_agent.verify_files_dir == exploit_agent.tmp_dir / "verify_files"
    assert exploit_agent.verify_script == exploit_agent.verify_files_dir / "verify.sh"


def test_remove_verify_files(exploit_agent):
    """Test that _remove_verify_files removes directory if it exists."""
    # Create the directory
    verify_dir = exploit_agent.verify_files_dir
    verify_dir.mkdir(parents=True, exist_ok=True)
    test_file = verify_dir / "test.txt"
    test_file.write_text("test content")

    # Verify directory exists before removal
    assert verify_dir.exists()
    assert test_file.exists()

    # Remove the directory
    exploit_agent._remove_verify_files(verify_dir)

    # Verify directory no longer exists
    assert not verify_dir.exists()
    assert not test_file.exists()


def test_copy_verify_files(exploit_agent):
    """Test that _copy_verify_files copies directory contents correctly."""
    # Create source directory with test files
    source_dir = exploit_agent.bounty_dir / "verify_files"
    source_dir.mkdir(parents=True, exist_ok=True)
    source_file = source_dir / "test.txt"
    source_file.write_text("test content")
    source_script = source_dir / "verify.sh"
    source_script.write_text("#!/bin/bash\necho test")
    source_script.chmod(0o755)

    # Create destination directory
    dest_dir = exploit_agent.verify_files_dir

    # Copy the files
    exploit_agent._copy_verify_files(source_dir, dest_dir)

    # Verify files were copied correctly
    assert dest_dir.exists()
    assert (dest_dir / "test.txt").exists()
    assert (dest_dir / "test.txt").read_text() == "test content"
    assert (dest_dir / "verify.sh").exists()
    assert (dest_dir / "verify.sh").read_text() == "#!/bin/bash\necho test"


def test_reset_verify_files(exploit_agent):
    """Test that reset_verify_files removes existing directory and copies from source."""
    # Create original verify_files directory
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    orig_dir.mkdir(parents=True, exist_ok=True)
    orig_file = orig_dir / "verify.sh"
    orig_file.write_text("#!/bin/bash\necho original")
    orig_file.chmod(0o755)

    # Create existing verify_files directory with different content
    verify_dir = exploit_agent.verify_files_dir
    verify_dir.mkdir(parents=True, exist_ok=True)
    verify_file = verify_dir / "verify.sh"
    verify_file.write_text("#!/bin/bash\necho old")
    verify_file.chmod(0o755)

    # Reset verify files
    exploit_agent.reset_verify_files()

    # Verify files were reset correctly
    assert verify_dir.exists()
    assert verify_file.exists()
    assert verify_file.read_text() == "#!/bin/bash\necho original"


def test_reset_verify_files_not_exists(exploit_agent):
    """Test that reset_verify_files raises exception when directory doesn't exist."""
    # Ensure verify_files directory doesn't exist
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    if orig_dir.exists():
        shutil.rmtree(orig_dir)

    # Verify exception is raised
    with pytest.raises(
        Exception, match=f"Verify files directory not found at {orig_dir}"
    ):
        exploit_agent.reset_verify_files()


@pytest.mark.asyncio
async def test_reset_verify_files_in_run_exploit_verify(exploit_agent):
    """Test that _run_exploit_verify calls reset_verify_files and uses the right directory."""
    # Set up necessary fixture state
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    exploit_agent.last_action_message = None

    # Create verify files directory in the bounty directory
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    orig_dir.mkdir(parents=True, exist_ok=True)
    orig_file = orig_dir / "verify.sh"
    orig_file.write_text("#!/bin/bash\necho verify")
    orig_file.chmod(0o755)

    # Setup mocks
    mock_run_command = AsyncMock()
    mock_run_command.return_value.returncode = 0
    mock_run_command.return_value.stdout = "verify output"

    # Set up Docker mock for the first part of _run_exploit_verify
    docker_mock = MagicMock()
    docker_mock.resource_id = "test_docker"
    docker_mock.run = AsyncMock()
    docker_mock.run.return_value = ActionMessage(
        resource_id="docker", message="exploit output"
    )
    exploit_agent.resources = MagicMock()
    exploit_agent.resources.docker = docker_mock

    # Create a spy on reset_verify_files to track calls without changing behavior
    reset_spy = patch.object(
        exploit_agent, "reset_verify_files", wraps=exploit_agent.reset_verify_files
    )

    with (
        patch("agents.exploit_agent.exploit_agent.run_command_async", mock_run_command),
        patch("agents.exploit_agent.exploit_agent.git_clean"),
        reset_spy,
    ):
        # Run the method
        result = await exploit_agent._run_exploit_verify()

        # Assert reset_verify_files was called
        exploit_agent.reset_verify_files.assert_called_once()

        # Verify run_command_async was called with correct working directory
        calls = mock_run_command.call_args_list
        assert len(calls) > 0

        # Find the call for verify.sh
        verify_call = next(
            (call for call in calls if call[0][0] == "bash verify.sh"), None
        )
        assert verify_call is not None
        assert verify_call[1]["work_dir"] == exploit_agent.verify_files_dir

        # Verify the exit code was returned
        assert result == 0
