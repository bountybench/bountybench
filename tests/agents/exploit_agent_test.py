import unittest
import os
import shutil
from resources.docker_resource import DockerResource, DockerResourceConfig
from resources.init_files_resource import InitFilesResourceConfig, InitFilesResource
from resources.setup_resource import SetupResource, SetupResourceConfig
from resources.kali_env_resource import KaliEnvResource, KaliEnvResourceConfig
from resources.utils import read_bounty_metadata, read_repo_metadata
from responses.command_response import CommandResponse
from responses.answer_response import AnswerResponse
from responses.base_response import BaseResponse
from unittest.mock import patch, MagicMock


from agents.exploit_agent.exploit_agent import ExploitAgentConfig, ExploitAgent
from responses.exploit_response import ExploitResponse


class TestExploitAgent(unittest.TestCase):
    def setUp(self):
        mock_logger = MagicMock()
        mock_logger._initialized = True
        mock_logger.initialize = MagicMock()
        mock_logger.add_agent = MagicMock()
        mock_logger._ensure_initialized = MagicMock()

        # Patch both potential import locations
        patchers = [
            patch('utils.workflow_logger.workflow_logger', mock_logger),
            patch('agents.base_agent.workflow_logger', mock_logger)
        ]
        
        # Start all patches and set up cleanup
        for patcher in patchers:
            patcher.start()
            self.addCleanup(patcher.stop)

        repo = "lunary"
        # Set up the test environment - using lunary as an environment
        self.test_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        self.exploit_files_src = os.path.join(self.test_dir, "bountybench", repo, "bounties", "bounty_0", "exploit_files")
        
        task_repo_dir = f"bountybench/{repo}"
        bounty_number = "0"
        files_dir, tmp_dir = "codebase", "tmp"

        # Read metadata
        repo_metadata = read_repo_metadata(str(task_repo_dir))
        bounty_metadata = read_bounty_metadata(str(task_repo_dir), bounty_number)

        init_files=InitFilesResource("init_files",
            InitFilesResourceConfig(
                    task_dir=task_repo_dir,
                    files_dir_name=files_dir,
                    tmp_dir_name=tmp_dir,
                    vulnerable_commit=bounty_metadata['vulnerable_commit']
            )
        )
        
        self.task_repo_dir = os.path.abspath(task_repo_dir)
        self.tmp_dir = os.path.join(self.task_repo_dir, tmp_dir)
        self.tmp_exploit_files = "/tmp/exploit_files"  # Path in the Kali container


        setup_repo_env_script = os.path.join(str(self.task_repo_dir), "setup_repo_env.sh")
        if os.path.exists(setup_repo_env_script):
            repo_resource = SetupResource("repo_resource",
                SetupResourceConfig(
                    task_level_setup=False,
                    task_dir=self.task_repo_dir,
                    files_dir=files_dir
                )
            )

        task_server = None
        target_host = repo_metadata["target_host"]
        if target_host:
            task_server = SetupResource("task_server",
                SetupResourceConfig(
                    task_level_setup=True,
                    task_dir=task_repo_dir,
                    files_dir=files_dir,
                    bounty_number=bounty_number,
                    server_address=target_host
                )
            )

        docker = DockerResource("docker", DockerResourceConfig())
        



        exploit_files_path = os.path.join(tmp_dir, "exploit_files")
        patch_files_path = os.path.join(tmp_dir, "patch_files")
        os.makedirs(patch_files_path, exist_ok=True)
        os.makedirs(exploit_files_path, exist_ok=True)

        kali_env = KaliEnvResource("kali_env",
            KaliEnvResourceConfig(task_dir=self.task_repo_dir,
                    bounty_number=bounty_number,
                    volumes={
                        os.path.abspath(tmp_dir): {"bind": "/app", "mode": "rw"},
                        os.path.abspath(exploit_files_path): {"bind": "/app/exploit_files", "mode": "rw"},
                        os.path.abspath(patch_files_path): {"bind": "/app/patch_files", "mode": "rw"},
                        "/tmp": {"bind": "/tmp", "mode": "rw"}
            })
        )

            
        
        
        # Initialize the ExploitAgent
        self.agent = ExploitAgent(ExploitAgentConfig(bounty_dir=os.path.join(self.task_repo_dir, "bounties", bounty_number)))
        self.agent.kali_env = kali_env
        self.agent.docker = docker
        self.agent.init_files = init_files
        self.agent.repo_resource = repo_resource
        self.agent.task_server = task_server

    
    def test_exploit_workflow(self):
        # Step 1: Initial run with no exploit files
        initial_response = self.agent.run([CommandResponse("Command: ls")])

      
        self.assertIsInstance(initial_response, ExploitResponse)
        expected_initial_response = "No exploit.sh found at /tmp/exploit_files/exploit.sh.\nNo exploit script found."

       
        self.assertIn(expected_initial_response, initial_response.response)
      
        # Step 2: Copy all exploit files to the Kali container
        self.copy_exploit_files_to_kali()
        
        
        # Verify the files were copied
        stdout, stderr = self.agent.kali_env.run_command(f"ls -l {self.tmp_exploit_files}")
        if stderr:
            self.fail(f"Failed to list files: {stderr}")
        for file in os.listdir(self.exploit_files_src):
            self.assertIn(file, stdout)

        # Step 3: Run with exploit files present
        exploit_response = self.agent.run([CommandResponse("Command: ls")])
        print(exploit_response.response)
        
        '''
        # Check if the exploit was successful or not
        if isinstance(exploit_response, AnswerResponse):
            self.assertIn("Exploit executed successfully", exploit_response.response)
            self.assertIn("Ready for patching", exploit_response.response)
        else:
            self.assertIsInstance(exploit_response, BaseResponse)
            self.assertIn("Exploit failed", exploit_response.response)
            
            # Print the exploit output for debugging
            print("Exploit output:")
            print(exploit_response.response)
            
            self.fail("Exploit execution failed. See output above for details.")
        """
        '''
        
    def copy_exploit_files_to_kali(self):
        # Ensure the destination directory exists in the Kali container
        self.agent.kali_env.run_command(f"mkdir -p {self.tmp_exploit_files}")

        # Copy each file from the source directory to the Kali container
        for filename in os.listdir(self.exploit_files_src):
            src_file = os.path.join(self.exploit_files_src, filename)
            dest_file = f"{self.tmp_exploit_files}/{filename}"
            
            with open(src_file, 'r') as f:
                content = f.read()
            
            create_file_cmd = f"cat << 'EOF' > {dest_file}\n{content}\nEOF"
            stdout, stderr = self.agent.kali_env.run_command(create_file_cmd)
            if stderr:
                self.fail(f"Failed to create {filename}: {stderr}")
            
            # Set permissions
            self.agent.kali_env.run_command(f"chmod 755 {dest_file}")
   

    def tearDown(self):
        # Clean up: remove the temporary exploit files from the Kali container
        self.agent.kali_env.run_command(f"rm -rf {self.tmp_exploit_files}")

if __name__ == '__main__':
    unittest.main()