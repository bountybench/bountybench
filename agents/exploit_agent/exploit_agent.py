import atexit
from dataclasses import dataclass
import os
import shutil
import time
from pathlib import Path
from typing import List, Optional, Tuple

import docker

from agents.base_agent import AgentConfig, BaseAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.kali_env_resource import KaliEnvResource
from resources.setup_resource import SetupResource
from responses.command_response import CommandResponse
from responses.exploit_response import ExploitResponse
from responses.response import Response
import time
from tenacity import retry, stop_after_attempt, wait_fixed

from utils.logger import get_main_logger

logger = get_main_logger(__name__)

@dataclass
class ExploitAgentConfig(AgentConfig):
    bounty_dir: str
    task_dir: str

class ExploitAgent(BaseAgent):
    """
    ExploitAgent is responsible for managing and executing exploit scripts.
    
    This agent checks for the presence of an exploit.sh file, executes it,
    and verifies its success. It also handles the copying of exploit files,
    restarting of resources, and storing of exploit results.
    """

    # Instead of just listing classes, we declare (ResourceClass, "attribute_name")
    # so that in BaseAgent, self.attribute_name = resource_manager.get_resource("attribute_name").
    REQUIRED_RESOURCES = [
        (InitFilesResource, "init_files"), 
        (KaliEnvResource, "kali_env"),
        (DockerResource, "docker")
    ]
    OPTIONAL_RESOURCES = [
        (SetupResource, "task_server"),
        (SetupResource, "repo_resource")
    ]
    ACCESSIBLE_RESOURCES = [
        (SetupResource, "task_server"),
        (SetupResource, "repo_resource"),
       (InitFilesResource, "init_files"),
        (KaliEnvResource, "kali_env"),
        (DockerResource, "docker")
    ]
    
    def __init__(self, agent_id: str, agent_config: ExploitAgentConfig):
            
            #self.bounty_dir = bounties/bounty_0
            #self.exploits_dir_name = "exploits"
            #self.exploits_dir = bountybench/setuptools/bounties/bounty_0/exploits
            #self.tmp_exploits_dir_name  = "exploit_files"
            #self.tmp_exploits_dir  = "bountybench/setuptools/tmp/bounties/bounty_0/exploit_files"
            self.bounty_dir = Path(agent_config.bounty_dir)
            self.task_dir = Path(agent_config.task_dir)
            self.exploits_dir_name = "agent_exploits"
            self.exploits_dir = Path(agent_config.task_dir) / self.bounty_dir / self.exploits_dir_name
            self.exploits_dir.mkdir(parents=True, exist_ok=True)
            self.tmp_exploits_dir_name = "exploit_files"
            self.tmp_exploits_dir = self.task_dir /"tmp" / self.bounty_dir / self.tmp_exploits_dir_name
            self.log_history = []


            super().__init__(agent_id, agent_config)

            atexit.register(self.cleanup)


    def run(self, responses: List[Response]) -> Response:
        """Execute the main workflow of the ExploitAgent."""
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        
        response = responses[0]

        #exploit_script = bountybench/setuptools/tmp/bounties/bounty_0/exploit_files/exploit.sh
        exploit_script = self.tmp_exploits_dir / "exploit.sh"

        if exploit_script.exists():
            self.log_history.append(f"Found exploit script at: {exploit_script}")
            execute_response = self.execute(response)
            self.log_history.clear()
            return execute_response
        else:
            self.log_history.append(f"No exploit.sh found at {exploit_script}.")
            log_message = "\n".join(self.log_history)
            self.log_history.clear()
            logger.info(log_message)
            return ExploitResponse(response=f"{log_message}\nNo exploit script found.", success=False, exploit_files_dir="")

    def execute(self, command_response: CommandResponse) -> Response:
        """Execute the exploit workflow."""
        try:
            self.restart_resources()
            exploit_output, exit_code = self.run_exploit()

            if exit_code == 0:
                copied_files_dir = self._store_exploit()
                if copied_files_dir:
                    logger.status(f"Exploit executed successfully. Files copied to {copied_files_dir}.", True)
                    log_message = "\n".join(self.log_history)
                    return ExploitResponse(response=f"{log_message}\nExploit executed successfully.", success=True, exploit_files_dir=copied_files_dir)
                else:
                    log_message = "Error copying over exploit files. Cannot proceed to patching."
                    logger.status(log_message)
                    self.log_history.append(log_message)
                    log_message = "\n".join(self.log_history)
                    return ExploitResponse(response=f"{log_message}\nError copying exploit files.", success=False, exploit_files_dir="")
            else:
                log_message = f"Exploit failed with exit code {exit_code}. Output: {exploit_output}"
                logger.status(log_message)
                self.log_history.append(log_message)
                exploit_log = "\n".join(self.log_history)
                return ExploitResponse(response=exploit_log, success=False, exploit_files_dir="")
        except Exception as e:
            log_message = f"Error during exploit execution: {str(e)}"
            logger.status(log_message)
            self.log_history.append(log_message)
            exploit_log = "\n".join(self.log_history)
            return ExploitResponse(response=exploit_log, success=False, exploit_files_dir="")

    def restart_resources(self):
        """Restart necessary resources."""
        # Since we declared (SetupResource, "task_server") and (SetupResource, "repo_resource")
        # as optional resources, the parent's code sets self.task_server and self.repo_resource if found
        self._restart_resource(self.task_server, "task_server")
        self._restart_resource(self.repo_resource, "repo_resource")

    def _restart_resource(self, resource, resource_name: str):
        """Restart a specific resource."""
        if resource:
            try:
                resource.restart()
                logger.info(f"{resource_name} resource restarted successfully.")
            except Exception as e:
                logger.error(f"Failed to restart {resource_name.lower()} resource: {e}")

    
    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
    def run_exploit(self) -> Tuple[str, int]:
        """Run the exploit script in a Docker container."""
        # Here we rely on self.init_files from (InitFilesResource, "init_files")

       #exploit_script = bountybench/setuptools/tmp/bounties/bounty_0/exploit_files/exploit.sh

        volumes = {
            os.path.abspath(self.init_files.tmp_dir): {"bind": "/app", "mode": "rw"},
        }

        #/app/bountybench/setuptools/tmp/

        exploit_command = f"cd {self.bounty_dir / self.tmp_exploits_dir_name} && bash exploit.sh"
        try:
            exploit_result = self.docker.execute(
                docker_image="cybench/cybounty:latest",
                command=exploit_command,
                network="shared_net",
                volumes=volumes,
            )
            return exploit_result
        except docker.errors.ContainerError as e:
            logger.error(f"Container error during exploit: {str(e)}")
            return str(e), 1

    def _store_exploit(self) -> Optional[str]:
        """Store the exploit files in a timestamped directory."""
        try:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            new_exploit_dir = f"{self.exploits_dir}-{timestamp}"

            if self.tmp_exploits_dir.exists() and self.tmp_exploits_dir.is_dir():
                if any(self.tmp_exploits_dir.iterdir()):
                    shutil.copytree(str(self.tmp_exploits_dir), new_exploit_dir)
                    logger.info(f"Exploits successfully moved to {new_exploit_dir}.")
                    return new_exploit_dir
                else:
                    logger.warning("Exploits directory is empty. No files to move.")
            else:
                logger.warning("No exploits directory found to move.")
        except Exception as e:
            logger.error(f"Failed to move exploits directory: {e}")

        return None

    def cleanup(self):
        """Clean up temporary files and directories."""
        try:
            if self.exploits_dir.exists():
                shutil.rmtree(self.exploits_dir)
                logger.info(f"Cleaned up temporary exploits directory: {self.exploits_dir}")
        except Exception as e:
            logger.info(f"Error during final cleanup: {e}")

    def to_dict(self) -> dict:
        """Serializes the ExploitAgent state to a dictionary."""
        return {
            'bounty_dir': str(self.bounty_dir),
            'exploits_dir': str(self.exploits_dir),
            'tmp_exploits_dir': str(self.tmp_exploits_dir),
            'log_history': self.log_history,
            'agent_id': self.agent_id,
            'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S%z')
        }

    @classmethod
    def from_dict(cls, data: dict, **kwargs) -> 'ExploitAgent':
        """
        Creates an ExploitAgent instance from a serialized dictionary.
        """
        kwargs['bounty_dir'] = data['bounty_dir']
        agent = cls(**kwargs)
        agent.exploits_dir = Path(data['exploits_dir'])
        agent.tmp_exploits_dir = Path(data['tmp_exploits_dir'])
        agent.log_history = data['log_history']
        agent._agent_id = data['agent_id']
        return agent

    def save_to_file(self, filepath: str) -> None:
        """
        Saves the agent state to a JSON file.
        """
        import json
        state = self.to_dict()
        with open(filepath, 'w') as f:
            json.dump(state, f, indent=2)

    @classmethod
    def load_from_file(cls, filepath: str, **kwargs) -> 'ExploitAgent':
        """
        Loads an agent state from a JSON file.
        """
        import json
        with open(filepath, 'r') as f:
            data = json.load(f)
        return cls.from_dict(data, **kwargs)