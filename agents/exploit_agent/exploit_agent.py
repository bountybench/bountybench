import atexit
import os
import shutil
import subprocess
import time
from typing import List, Tuple

from agents.base_agent import BaseAgent
from agents.simple_agent.simple_agent import SimpleExecutorAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.task_server_resource import TaskServerResource
from responses.answer_response import AnswerResponse
from responses.command_response import CommandResponse
from responses.observation import Observation
from responses.command_response_interface import CommandResponseInterface
from responses.response import Response
from utils.logger import get_main_logger
from responses.base_response import BaseResponse


logger = get_main_logger(__name__)


class ExploitAgent(BaseAgent):
    def __init__(self, config, *args, **kwargs):
        super().__init__()
        self.simple_agent = SimpleExecutorAgent(config, *args, **kwargs)
        self._initialize_resources()

        self.bounty_dir = kwargs.get('bounty_dir')
        self.exploit_files_dir_name = "exploit_files"
        self.exploit_files_dir = os.path.join(self.init_files.tmp_dir, self.exploit_files_dir_name)

        os.makedirs(self.exploit_files_dir, exist_ok=True)
    
    def _initialize_resources(self):
        try:
            self.init_files = self._get_resource(InitFilesResource)
            self.task_server = self._get_resource(TaskServerResource)
            self.docker_helper = self._get_resource(DockerResource)
        except KeyError as e:
            raise RuntimeError(f"{e.args[0]} not set up. Exploit agent cannot start.")
    
    def _get_resource(self, resource_type):
        resources = self.resource_dict.get_items_of_resource_type(resource_type)
        if not resources:
            raise KeyError(f"{resource_type.__name__}")
        return resources[0]

    def run(self, responses: List[Response]) -> Response:
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        simple_agent_response = self.simple_agent.run(responses)
        if issubclass(simple_agent_response.__class__, CommandResponseInterface):
            if self.get_exploit_files(self.init_files.tmp_dir):
                logger_message = "`exploit.sh` detected, verifying exploit..."
                logger.info(logger_message)
                verify_response =  self.execute_check(simple_agent_response)
                return verify_response
            else: 
              logger_message = "`exploit.sh` not detected, skipping."
              logger.info(logger_message)
              patch_response = BaseResponse("\n".join(self.log_history))
              return patch_response
        else: 
            raise TypeError(f"Response not of an interpretable type. The response type is {simple_agent_response.__class__} but we expect a class of CommandResponseInterface")
        
    def execute_check(self, simple_agent_response: CommandResponse) -> Response:
        """
        This function executes `exploit.sh` followed by the `verify.sh` if it exists
        """
        # To ensure internal state as expected (e.g. database rehydrated) restart task_server
        self.restart_task_server_resource()
        
        try:
            exploit_output = self.run_exploit()
            if (os.path.exists(os.path.join(self.init_files.tmp_dir, "verify.sh"))):
                success, message = self.run_verify(exploit_output)
                if success:
                    self.save_files()
                    return AnswerResponse("Verify passed exploit: {message}")
                else: 
                    simple_agent_response.set_observation(Observation(f"Exploit output: {exploit_output}\nVerify output: {message}"))
            else:
                simple_agent_response.set_observation(Observation(exploit_output))
        except Exception as e:
            error_response = f"`exploit.sh` failed with errors: {e}"
            logger.error(error_response)
            simple_agent_response.set_observation(
                Observation(f"Exploit output: {error_response}"))     
        return simple_agent_response
        
    def get_exploit_files(self, directory_path: str) -> str:
        """
        This function returns true if `exploit.sh` and `verify.sh` exist in codebase
        """
        if (os.path.exists(os.path.join(directory_path, "exploit_files", "exploit.sh"))):
            if (os.path.exists(os.path.join(directory_path, "verify.sh"))):
                logger.info("`exploit.sh` and `verify.sh` detected.")
                return True
            else:
                logger.info("`exploit.sh` detected but no `verify.sh`.")
                return True
        else:
            logger.info("No `exploit.sh` detected.")
            return False

    def run_exploit(self) -> str:
        """
        This function runs the exploit
        """
        volumes = {
            self.init_files.task_repo_dir: {"bind": "/app/", "mode": "rw"}
        }
        
        exploit_command = (
            f"cd {self.exploit_files_dir} && ./exploit.sh"
        )
        
        return self.docker_helper.execute(
            docker_image="cybench/cybounty:latest",
            command=exploit_command,
            network="shared_net",
            work_dir=None,
            volumes=volumes
        )    
    
    def run_verify(self) -> Tuple[bool, str]:
        """
        Run the verify.sh script.
        """
        logger_message = f"Running verify.sh"
        logger.info(logger_message)
        result = subprocess.run(['./verify.sh'],
                                cwd=self.init_files.tmp_dir, capture_output=True, text=True)
        logger_message = f"Verify.sh output:\n{result.stdout}"

        logger.info(logger_message)
        if result.returncode == 0:
            logger_message = "Verify succeeded."
            logger.info(logger_message)
            return True, result.stdout
        else: 
            logger_message = f"Exit code {result.returncode} returned from verify. Failed to verify exploit."
            logger.error(logger_message)
            return False, logger_message

    def save_files(self):
        """
        On success, move the exploit_files folder and verify.sh into bounty_dir folder.
        """
        try:
            new_exploit_dir = os.path.join(self.bounty_dir, "exploit_files")
            
            if os.path.exists(self.exploit_files_dir) and os.path.isdir(self.exploit_files_dir):
                if os.path.exists(os.path.join(self.exploit_files_dir, "exploit.sh")):  
                    shutil.move(self.exploit_files_dir, new_exploit_dir)
                    logger_message = f"exploit files successfully moved to {new_exploit_dir}."
                    logger.info(logger_message)
                    verify_path = os.path.join(self.init_files.tmp_dir, "verify.sh")
                    new_verify_path = os.path.join(self.bounty_dir, "verify.sh")
                    if os.path.exists(verify_path): 
                        shutil.move(verify_path, new_verify_path)
                        logger_message = f"Verify successfully moved to {new_verify_path}."
                        logger.info(logger_message)
                    else:
                        logger_message = "No verify script detected."
                        
                else:
                    logger_message = "Exploit directory is empty. No need to move."
                    logger.info(logger_message)
            else:
                logger_message = f"No exploit_files directory found to move."
                logger.warning(logger_message)
            
        except Exception as e:
            logger_message = f"Failed to move exploit_files directory: {e}"
            logger.error(logger_message)


    def restart_task_server_resource(self) -> bool:
        """
        This function restarts the task server resource
        """
        try:
            self.task_server.restart()
            logger_message = "Task server resource restarted successfully."
            logger.info(logger_message)
            return True
        except Exception as e:
            logger_message = f"Failed to restart task server resource: {e}"
            logger.error(logger_message)
            return False


