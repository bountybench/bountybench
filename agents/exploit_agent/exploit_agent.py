import logging
import os
import shutil
import subprocess
import time
from pathlib import Path
from typing import List, Optional, Tuple, Dict

import docker

from agents.base_agent import BaseAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.kali_env_resource import KaliEnvResource
from resources.setup_resource import SetupResource
from responses.answer_response import AnswerResponse
from responses.command_response import CommandResponse
from responses.command_response_interface import CommandResponseInterface
from responses.observation import Observation
from responses.response import Response
from responses.base_response import BaseResponse

logger = logging.getLogger(__name__)

class ExploitAgent(BaseAgent):
    """
    ExploitAgent is responsible for managing and executing exploit scripts.
    
    This agent checks for the presence of an exploit.sh file, executes it,
    and verifies its success. It also handles the copying of exploit files,
    restarting of resources, and storing of exploit results.
    """

    REQUIRED_RESOURCES = [InitFilesResource, KaliEnvResource, DockerResource]
    OPTIONAL_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource")]
    ACCESSIBLE_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource"), InitFilesResource, KaliEnvResource, DockerResource]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bounty_dir = Path(kwargs.get('bounty_dir'))
        self.exploits_dir_name = "exploits"
        self.exploits_dir = self.bounty_dir / self.exploits_dir_name
        self.tmp_exploits_dir = Path("/tmp/exploit_files")

        self.docker = self._get_resource(DockerResource)

        self.exploits_dir.mkdir(parents=True, exist_ok=True)

    def run(self, responses: List[Response]) -> Response:
        """Execute the main workflow of the ExploitAgent."""
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        
        response = responses[0]
        if not isinstance(response, CommandResponseInterface):
            raise TypeError(f"Expected CommandResponseInterface, got {type(response)}")

        exploit_script = self.tmp_exploits_dir / "exploit.sh"
        logger.info(f"Checking for exploit script at: {exploit_script}")

        if exploit_script.exists():
            logger.info(f"Found exploit script at: {exploit_script}")
            return self.execute(response)
        else:
            logger.info(f"No exploit.sh found at {exploit_script}.")
            return BaseResponse("No exploit script found.")

    def execute(self, command_response: CommandResponse) -> Response:
        """Execute the exploit workflow."""
        try:
            self._copy_exploit_files()
            self.restart_resources()
            exploit_output, exit_code = self.run_exploit()

            if exit_code == 0:
                copied_files_dir = self._store_exploit()
                if copied_files_dir:
                    logger.info(f"Exploit executed successfully. Files copied to {copied_files_dir}.")
                    command_response.set_observation(Observation("Exploit executed successfully. Ready for patching."))
                    return AnswerResponse(f"Exploit successful. Answer: {copied_files_dir}")
                else:
                    logger.error("Error copying over exploit files. Cannot proceed to patching.")
                    return BaseResponse("Error copying exploit files.")
            else:
                logger.info(f"Exploit failed with exit code {exit_code}. Output: {exploit_output}")
                return BaseResponse(f"Exploit failed. Exit code: {exit_code}")
        except Exception as e:
            logger.exception("Error during exploit execution")
            return BaseResponse(f"Error during exploit: {str(e)}")

    def _copy_exploit_files(self):
        """Copy exploit files from Kali container to local directory."""
        try:
            files = self.kali_env.run_command(f"ls -1 {self.tmp_exploits_dir}")[0].strip().split('\n')
            
            if self.exploits_dir.exists():
                shutil.rmtree(self.exploits_dir)
            self.exploits_dir.mkdir(parents=True, exist_ok=True)

            for file in files:
                source_path = self.tmp_exploits_dir / file
                dest_path = self.exploits_dir / file
                
                self.docker.copy_from_container(self.kali_env.container.name, str(source_path), str(dest_path))
                dest_path.chmod(0o755)
                logger.info(f"Copied and made executable: {file}")

            logger.info(f"Copied all exploit files from Kali container to {self.exploits_dir}")
        except Exception as e:
            logger.error(f"Failed to copy exploit files: {str(e)}")
            raise

    def restart_resources(self):
        """Restart necessary resources."""
        self._restart_resource(self.task_server, "Task server")
        self._restart_resource(self.repo_resource, "Repo")

    def _restart_resource(self, resource, resource_name: str):
        """Restart a specific resource."""
        if resource:
            try:
                resource.restart()
                logger.info(f"{resource_name} resource restarted successfully.")
            except Exception as e:
                logger.error(f"Failed to restart {resource_name.lower()} resource: {e}")

    def run_exploit(self) -> Tuple[str, int]:
        """Run the exploit script in a Docker container."""
        setup_files_dir = Path(self.init_files.task_repo_dir) / 'setup_files'
        volumes = {
            Path(self.init_files.task_repo_dir) / 'codebase': {"bind": "/app/codebase", "mode": "rw"},
            setup_files_dir: {"bind": "/app/setup_files", "mode": "rw"},
            "/tmp": {"bind": "/tmp", "mode": "rw"}
        }

        setup_command = "bash /app/setup_files/requirements.sh"
        exploit_command = "bash /tmp/exploit_files/exploit.sh"

        try:
            if (setup_files_dir / 'requirements.sh').exists():
                setup_result = self.docker.execute(
                    docker_image="cybench/cybounty:latest",
                    command=setup_command,
                    network="shared_net",
                    volumes=volumes,
                )
                if setup_result[1] != 0:
                    return f"Setup failed:\n{setup_result[0]}", setup_result[1]
            
            return self.docker.execute(
                docker_image="cybench/cybounty:latest",
                command=exploit_command,
                network="shared_net",
                volumes=volumes,
            )
        except docker.errors.ContainerError as e:
            logger.error(f"Container error during exploit: {str(e)}")
            return str(e), 1

    def _store_exploit(self) -> Optional[str]:
        """Store the exploit files in a timestamped directory."""
        try:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            new_exploit_dir = f"{self.exploits_dir}-{timestamp}"

            if self.exploits_dir.exists() and self.exploits_dir.is_dir():
                if any(self.exploits_dir.iterdir()):
                    shutil.move(str(self.exploits_dir), new_exploit_dir)
                    logger.info(f"Exploits successfully moved to {new_exploit_dir}.")
                    return new_exploit_dir
                else:
                    logger.warning("Exploits directory is empty. No files to move.")
            else:
                logger.warning("No exploits directory found to move.")
        except Exception as e:
            logger.error(f"Failed to move exploits directory: {e}")

        return None

    def cleanup(self):
        """Clean up temporary files and directories."""
        try:
            if self.exploits_dir.exists():
                shutil.rmtree(self.exploits_dir)
                logger.info(f"Cleaned up temporary exploits directory: {self.exploits_dir}")
        except Exception as e:
            logger.error(f"Error during final cleanup: {e}")