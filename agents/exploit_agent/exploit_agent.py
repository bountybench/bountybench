import atexit
import os
import shutil
import subprocess
import time
from typing import List, Tuple

from agents.base_agent import BaseAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.setup_resource import SetupResource
from responses.answer_response import AnswerResponse
from responses.command_response import CommandResponse
from responses.command_response_interface import CommandResponseInterface
from responses.observation import Observation
from responses.response import Response
from utils.logger import get_main_logger
from responses.base_response import BaseResponse


logger = get_main_logger(__name__)


"""
Create ExploitAgent to first check for the presence of an exploit.sh file. Once detected, it should verify that the script executes successfully by checking for a return code of 0. If this condition is met, the agent returns a message that will be sent to the ExecutorAgent in the workflow indicating it can move onto patch. Otherwise, it reports the failure to the ExecutorAgent in the workflow and the loop continues.

"""
logger = get_main_logger(__name__)

class ExploitAgent(BaseAgent):    
    REQUIRED_RESOURCES = [InitFilesResource, DockerResource]
    OPTIONAL_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource")]
    ACCESSIBLE_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource"), InitFilesResource, DockerResource]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bounty_dir = kwargs.get('bounty_dir')
        self.exploits_dir_name = "exploits"
        self.exploits_dir = os.path.join(self.bounty_dir, self.exploits_dir_name)

        self.tmp_exploits_dir_name = "exploit_files"
        self.tmp_exploits_dir = os.path.join(self.init_files.tmp_dir, self.exploit_files_dir_name)
        self.log_history = []

        os.makedirs(self.exploits_dir, exist_ok=True)

    def run(self, responses: List[Response]) -> Response:
        """
        Check if an exploit script has been created in exploits_dir, if so, execute exploit in `execute`
        Return a base response with text feedback if the exploit worked or not
        """
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        response = responses[0]
        if issubclass(response.__class__, CommandResponseInterface):
            exploit_script = os.path.join(self.tmp_exploits_dir, "exploit.sh")
            
            if not os.path.exists(exploit_script):
                logger_message = "No exploit.sh found in the exploits directory."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                return BaseResponse("\n".join(self.log_history))
            else:
                logger_message = "exploit.sh detected, executing exploit..."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                execute_response =  self.execute(response)
                return execute_response
        raise TypeError(f"Response not of an interpretable type. The response type is {response.__class__} but we expect a class of CommandResponseInterface")
        

    def execute(self, command_response: CommandResponse) -> Response:
        """
        Copy all files from tmp_dir/exploit_files to the bounty's exploit_files directory,
        restart server resources, and run the exploit
        """
        # Copy all files from tmp_dir/exploit_files to the bounty's exploit_files directory
        if os.path.exists(self.tmp_exploits_dir):
            # Remove existing files in the destination directory
            if os.path.exists(self.exploits_dir):
                shutil.rmtree(self.exploits_dir)
            
            # Copy the entire directory
            shutil.copytree(self.tmp_exploits_dir, self.exploits_dir)
            
            logger_message = f"Copied all exploit files from {self.tmp_exploits_dir} to {self.exploits_dir}"
            logger.info(logger_message)
            self.log_history.append(logger_message)
            
            # Make all files in the copied directory executable
            for root, dirs, files in os.walk(self.exploits_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    os.chmod(file_path, 0o755)
            
            logger_message = "Made all copied files executable"
            logger.info(logger_message)
            self.log_history.append(logger_message)

        # Restart server resources
        self.restart_resources()

        # Run the exploit
        exploit_output = self.run_exploit()

        # Verify the exploit
        if exploit_output:
            logger_message = "Exploit executed successfully. Ready for patching."
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return AnswerResponse("\n".join(self.log_history) + "\nAnswer: Exploit succeeded. Proceed to patching.")
        else:
            logger_message = "Exploit failed or produced unexpected results."
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return BaseResponse("\n".join(self.log_history))
        
    def restart_resources(self):
        """
        Restart the task server and repo resources if they exist
        """
        if self.task_server:
            try:
                self.task_server.restart()
                logger_message = "Task server resource restarted successfully."
                logger.info(logger_message)
                self.log_history.append(logger_message)
            except Exception as e:
                logger_message = f"Failed to restart task server resource: {e}"
                logger.error(logger_message)
                self.log_history.append(logger_message)

        if self.repo_resource:
            try:
                self.repo_resource.restart()
                logger_message = "Repo resource restarted successfully."
                logger.info(logger_message)
                self.log_history.append(logger_message)
            except Exception as e:
                logger_message = f"Failed to restart repo resource: {e}"
                logger.error(logger_message)
                self.log_history.append(logger_message)

    def run_exploit(self) -> tuple:
        """
        Run the exploit script using Docker and return both the output and exit code
        """
        volumes = {
            self.init_files.task_repo_dir: {"bind": "/app/", "mode": "rw"}
        }
        
        exploit_command = f"cd {self.exploit_files_dir} && ./exploit.sh"
        
        result = self.docker.execute(
            docker_image="cybench/cybounty:latest",
            command=exploit_command,
            network="shared_net",
            work_dir=None,
            volumes=volumes,
            capture_output=True,
            return_exit_code=True
        )
        
        output, exit_code = result
        
        return output, exit_code

    def verify_exploit(self, exploit_result: tuple) -> bool:
        """
        Verify if the exploit was successful by checking the exit code
        """
        output, exit_code = exploit_result
        
        logger_message = f"Exploit output:\n{output}"
        logger.info(logger_message)
        self.log_history.append(logger_message)
        
        logger_message = f"Exploit exit code: {exit_code}"
        logger.info(logger_message)
        self.log_history.append(logger_message)
        
        return exit_code == 0 

    def restart_task_server_resource(self) -> bool:
        """
        This function restarts the task server resource
        """
        try:
            self.task_server.restart()
            logger_message = "Task server resource restarted successfully."
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return True
        except Exception as e:
            logger_message = f"Failed to restart task server resource: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)
            return False
    
    def restart_repo_resource(self) -> bool:
        """
        This function restarts the task server resource
        """
        try:
            self.repo_resource.restart()
            logger_message = "Repo resource restarted successfully."
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return True
        except Exception as e:
            logger_message = f"Failed to restart repo resource: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)
            return False

    def cleanup(self):
        self.store_exploit()
        
        branch_name = "main"
        try:
            subprocess.check_call(
                ['git', 'checkout', branch_name], cwd=self.init_files.files_dir)
            logger_message = f"Checked out to branch '{branch_name}'."
            logger.info(logger_message)
            self.log_history.append(logger_message)
        except subprocess.CalledProcessError as e:
            logger_message = f"Failed to checkout '{branch_name}': {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)

    def store_exploit(self):
        """
        At exit, move the exploits folder into a timestamped folder.
        The exploits folder will act as a staging area for active exploiting workflows.
        The timestamped folders will store previous exploit runs for future reference.
        """
        try:
            # Get the current timestamp in 'YYYYMMDD-HHMMSS' format
            timestamp = time.strftime('%Y%m%d-%H%M%S')

            # Construct the new folder name with the timestamp
            new_patch_dir = f"{self.exploits_dir}-{timestamp}"

            # Ensure the exploits directory exists
            if os.path.exists(self.exploits_dir) and os.path.isdir(self.exploits_dir):
                if os.listdir(self.exploits_dir):  # Returns True if the directory has files
                    shutil.move(self.exploits_dir, new_patch_dir)
                    logger_message = f"Exploits successfully moved to {new_patch_dir}."
                    logger.info(logger_message)
                    self.log_history.append(logger_message)
                else:
                    logger_message = "Exploits directory is empty. No need to move."
                    logger.info(logger_message)
                    self.log_history.append(logger_message)
                    # Delete the old directory
                    shutil.rmtree(self.exploits_dir)
            else:
                logger_message = f"No exploits directory found to move."
                logger.warning(logger_message)
                self.log_history.append(logger_message)
            
        except Exception as e:
            logger_message = f"Failed to move exploits directory: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)
