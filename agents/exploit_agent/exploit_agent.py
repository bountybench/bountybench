import os
import shutil
import time
from typing import List, Optional, Tuple

import docker

from agents.base_agent import BaseAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.setup_resource import SetupResource
from responses.answer_response import AnswerResponse
from responses.command_response import CommandResponse
from responses.command_response_interface import CommandResponseInterface
from responses.response import Response
from utils.logger import get_main_logger
from responses.base_response import BaseResponse

logger = get_main_logger(__name__)

class ExploitAgent(BaseAgent):
    """
    ExploitAgent is responsible for managing and executing exploit scripts.
    
    This agent checks for the presence of an exploit.sh file, executes it,
    and verifies its success. It also handles the copying of exploit files,
    restarting of resources, and storing of exploit results.

    Attributes:
        REQUIRED_RESOURCES (List): List of required resources for this agent.
        OPTIONAL_RESOURCES (List[Tuple]): List of optional resources for this agent.
        ACCESSIBLE_RESOURCES (List[Union[Tuple, Type]]): List of accessible resources for this agent.
    """

    REQUIRED_RESOURCES = [InitFilesResource, DockerResource]
    OPTIONAL_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource")]
    ACCESSIBLE_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource"), InitFilesResource, DockerResource]

    def __init__(self, *args, **kwargs):
        """
        Initialize the ExploitAgent.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        super().__init__(*args, **kwargs)
        self.bounty_dir = kwargs.get('bounty_dir')
        self.exploits_dir_name = "exploits"
        self.exploits_dir = os.path.join(self.bounty_dir, self.exploits_dir_name)

        self.tmp_exploits_dir_name = "exploit_files"
        self.tmp_exploits_dir = os.path.join(self.init_files.tmp_dir, self.tmp_exploits_dir_name)
        self.log_history = []

        os.makedirs(self.exploits_dir, exist_ok=True)

    def run(self, responses: List[Response]) -> Response:
        """
        Check for the presence of an exploit script and execute it if found.

        Args:
            responses (List[Response]): List of responses, expected to contain a single CommandResponse.

        Returns:
            Response: A Response object indicating the result of the exploit execution.

        Raises:
            ValueError: If more than one response is provided.
            TypeError: If the response is not of the expected type.
        """
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        response = responses[0]
        if issubclass(response.__class__, CommandResponseInterface):
            exploit_script = os.path.join(self.tmp_exploits_dir, "exploit.sh")
            if not os.path.exists(exploit_script):
                logger_message = "No exploit.sh found in the exploits directory."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                return BaseResponse("\n".join(self.log_history))
            else:
                logger_message = "exploit.sh detected, executing exploit..."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                execute_response = self.execute(response)
                return execute_response
        raise TypeError(f"Response not of an interpretable type. The response type is {response.__class__} but we expect a class of CommandResponseInterface")

    def execute(self, command_response: CommandResponse) -> Response:
        """
        Execute the exploit script and process the results.

        This method copies exploit files, restarts resources, runs the exploit,
        and verifies the results.

        Args:
            command_response (CommandResponse): The command response object.

        Returns:
            Response: An AnswerResponse if the exploit succeeds, otherwise a BaseResponse.
        """
        self._copy_exploit_files()
        self.restart_resources()
        exploit_output, exit_code = self.run_exploit()

        if exit_code == 0:
            logger_message = "Exploit executed successfully." 
            copied_files_dir = self._store_exploit()
            if copied_files_dir:
                logger_message += f" Exploit files copied successfully to {copied_files_dir}. Ready for patching."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                return AnswerResponse("\n".join(self.log_history) + f"\nAnswer: {copied_files_dir}")
            else:
                error_message = "Error copying over exploit files. Cannot proceed to patching."
                logger.error(error_message)
                self.log_history.append(error_message)
                raise Exception(error_message)
        else:
            logger_message = f"Exploit failed with exit code {exit_code}. Output: {exploit_output}"
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return BaseResponse("\n".join(self.log_history))

    def _copy_exploit_files(self):
        """
        Copy exploit files from temporary directory to the exploits directory.

        This method also makes all copied files executable.
        """
        if os.path.exists(self.tmp_exploits_dir):
            if os.path.exists(self.exploits_dir):
                shutil.rmtree(self.exploits_dir)
            
            shutil.copytree(self.tmp_exploits_dir, self.exploits_dir)
            
            logger_message = f"Copied all exploit files from {self.tmp_exploits_dir} to {self.exploits_dir}"
            logger.info(logger_message)
            self.log_history.append(logger_message)
            
            for root, dirs, files in os.walk(self.exploits_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    os.chmod(file_path, 0o755)
            
            logger_message = "Made all copied files executable"
            logger.info(logger_message)
            self.log_history.append(logger_message)

    def restart_resources(self):
        """
        Restart the task server and repo resources if they exist.
        """
        self._restart_resource(self.task_server, "Task server")
        self._restart_resource(self.repo_resource, "Repo")

    def _restart_resource(self, resource, resource_name):
        """
        Restart a given resource and log the result.

        Args:
            resource: The resource to restart.
            resource_name (str): The name of the resource for logging purposes.
        """
        if resource:
            try:
                resource.restart()
                logger_message = f"{resource_name} resource restarted successfully."
                logger.info(logger_message)
                self.log_history.append(logger_message)
            except Exception as e:
                logger_message = f"Failed to restart {resource_name.lower()} resource: {e}"
                logger.error(logger_message)
                self.log_history.append(logger_message)

    def run_exploit(self) -> Tuple[str, int]:
        """
        Run the exploit script using Docker and return both the output and exit code.

        Returns:
            Tuple[str, int]: A tuple containing the output and exit code of the exploit script.
        """

        volumes = {
            self.exploits_dir: {"bind": "/app/exploits", "mode": "rw"}
        }
        
        exploit_command = "cd /app/exploits && ./exploit.sh"
        
        try:
            result = self.docker.execute(
                docker_image="cybench/cybounty:latest",
                command=exploit_command,
                network="shared_net",
                work_dir=None,
                volumes=volumes,
            )
            output, exit_code = result
            return output, exit_code
        except docker.errors.ContainerError as e:
            return str(e), 1  # Return the error message and a non-zero exit code
        
    def verify_exploit(self, exploit_result: Tuple[str, int]) -> bool:
        """
        Verify if the exploit was successful by checking the exit code.

        Args:
            exploit_result (Tuple[str, int]): The output and exit code from running the exploit.

        Returns:
            bool: True if the exploit was successful (exit code 0), False otherwise.
        """
        output, exit_code = exploit_result
        
        logger_message = f"Exploit output:\n{output}"
        logger.info(logger_message)
        self.log_history.append(logger_message)
        
        logger_message = f"Exploit exit code: {exit_code}"
        logger.info(logger_message)
        self.log_history.append(logger_message)
        
        return exit_code == 0 


    def _store_exploit(self) -> Optional[str]:
        """
        Store the exploits folder in a timestamped directory.

        This method moves the exploits folder into a timestamped folder for future reference.
        The exploits folder acts as a staging area for active exploiting workflows.

        Returns:
            Optional[str]: The path to the new exploit directory if successful, None otherwise.
        """
        try:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            new_exploit_dir = f"{self.exploits_dir}-{timestamp}"

            if os.path.exists(self.exploits_dir) and os.path.isdir(self.exploits_dir):
                if os.listdir(self.exploits_dir):
                    shutil.move(self.exploits_dir, new_exploit_dir)
                    logger_message = f"Exploits successfully moved to {new_exploit_dir}."
                    logger.info(logger_message)
                    self.log_history.append(logger_message)
                    return new_exploit_dir
                else:
                    logger_message = "Exploits directory is empty. No files to move."
                    logger.warning(logger_message)
                    self.log_history.append(logger_message)
            else:
                logger_message = "No exploits directory found to move."
                logger.warning(logger_message)
                self.log_history.append(logger_message)
            
        except Exception as e:
            logger_message = f"Failed to move exploits directory: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)
        
        return None

    def cleanup(self):
        """
        Perform final cleanup operations.
        This method is intended to be called when the agent is being destroyed or the process is ending.
        """
        try:
            if os.path.exists(self.exploits_dir):
                shutil.rmtree(self.exploits_dir)
                logger_message = f"Cleaned up temporary exploits directory: {self.exploits_dir}"
                logger.info(logger_message)
                self.log_history.append(logger_message)
        except Exception as e:
            logger_message = f"Error during final cleanup: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)