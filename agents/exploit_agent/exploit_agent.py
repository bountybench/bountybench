import atexit
from dataclasses import dataclass
import os
import shutil
import subprocess
import time
from pathlib import Path
from typing import List, Optional, Tuple

import docker

from agents.base_agent import AgentConfig, BaseAgent
from messages.agent_messages.agent_message import AgentMessage
from resources.default_resource import DefaultResource
from messages.agent_messages.exploit_agent_message import ExploitAgentMessage
from messages.message import Message
import time
from tenacity import retry, stop_after_attempt, wait_fixed

from utils.logger import get_main_logger

logger = get_main_logger(__name__)

@dataclass
class ExploitAgentConfig(AgentConfig):
    bounty_dir: str
    task_dir: str


    def to_dict(self):
        return {
            "bounty_dir": self.bounty_dir,
            "task_dir": self.task_dir,
        }

    @classmethod
    def from_dict(cls, data: dict):
        return cls(
            bounty_dir=data["bounty_dir"],
            task_dir=data["task_dir"],
        )

class ExploitAgent(BaseAgent):
    """
    ExploitAgent is responsible for managing and executing exploit scripts.
    
    This agent checks for the presence of an exploit.sh file, executes it,
    and verifies its success. It also handles the copying of exploit files,
    restarting of resources, and storing of exploit results.
    """

    REQUIRED_RESOURCES = [
        DefaultResource.INIT_FILES,
        DefaultResource.DOCKER,
    ]
    OPTIONAL_RESOURCES = [
        DefaultResource.BOUNTY_RESOURCE,
        DefaultResource.REPO_RESOURCE,
    ]
    ACCESSIBLE_RESOURCES = [
        DefaultResource.BOUNTY_RESOURCE,
        DefaultResource.REPO_RESOURCE,
        DefaultResource.INIT_FILES,
        DefaultResource.DOCKER,
    ]
    
    def __init__(self, agent_id: str, agent_config: ExploitAgentConfig):
            
        self.bounty_dir = Path(agent_config.bounty_dir)
        self.task_dir = Path(agent_config.task_dir)
        self.exploits_dir_name = "agent_exploits"
        self.exploits_dir = Path(agent_config.task_dir) / self.bounty_dir / self.exploits_dir_name
        self.exploits_dir.mkdir(parents=True, exist_ok=True)
        self.tmp_exploits_dir = self.task_dir / "tmp"
        self.log_history = []

        self._init_git_repo()

        super().__init__(agent_id, agent_config)

        atexit.register(self.cleanup)


    def _init_git_repo(self):
        """Initialize git repo in exploits directory if it doesn't exist"""
        if not (self.tmp_exploits_dir / '.git').exists():
            subprocess.run(['git', 'init'], cwd=self.tmp_exploits_dir, check=True)
            # Create .gitignore if needed
            gitignore_path = self.tmp_exploits_dir / '.gitignore'
            if not gitignore_path.exists():
                gitignore_path.write_text('*.log\n.DS_Store\n')
            # Initial commit
            subprocess.run(['git', 'add', '.'], cwd=self.tmp_exploits_dir)
            subprocess.run(['git', 'commit', '-m', 'Initial commit'], cwd=self.tmp_exploits_dir)
    
    def _has_changes(self) -> bool:
        """Check if there are any changes in the exploits directory"""
        try:
            result = subprocess.run([
                'git',
                f'--git-dir=.git',
                f'--work-tree=.',
                'status', '--porcelain'
            ], cwd=self.tmp_exploits_dir, capture_output=True, text=True)
            return bool(result.stdout.strip())
        except subprocess.CalledProcessError:
            logger.error("Failed to check git status")
            return True


    def _commit_changes(self):
        """Commit any changes in the exploits directory"""
        try:
            subprocess.run([
                'git',
                f'--git-dir=.git',
                f'--work-tree=.',
                'add', '.'
            ], cwd=self.tmp_exploits_dir)
            subprocess.run([
                'git',
                f'--git-dir=.git',
                f'--work-tree=.',
                'commit', '-m', f'Update exploit files at {time.strftime("%Y-%m-%d %H:%M:%S")}'
            ], cwd=self.tmp_exploits_dir)
        except subprocess.CalledProcessError:
            logger.error("Failed to commit changes")

    def _clean_untracked(self, cwd: Optional[Path] = None):
        """Clean untracked files using git clean"""
        try:
            subprocess.run([
                'git',
                '--git-dir=.git',
                '--work-tree=.',
                'clean', '-fd'
            ],
            cwd=self.tmp_exploits_dir if cwd is None else cwd,
            check=True,
            )
        except subprocess.CalledProcessError:
            logger.error("Failed to clean untracked files")

                
    async def run(self, messages: List[AgentMessage]) -> AgentMessage:
        """Execute the main workflow of the ExploitAgent."""
        if len(messages) != 1:
            raise ValueError(f"Accepts only a single message, but received {len(messages)} messages")
        
        prev_agent_message = messages[0]
        exploit_script = self.tmp_exploits_dir / "exploit.sh"

        if not exploit_script.exists():
            log_message = f"No exploit.sh found at {exploit_script}."
            self.log_history.append(log_message)
            log_message = "\n".join(self.log_history)
            self.log_history.clear()
            logger.info(log_message)


            agent_message = ExploitAgentMessage(agent_id=self.agent_id, message=f"{log_message}\nNo exploit script found.", prev=prev_agent_message)
            return agent_message



        if self._has_changes():
            log_message = f"Found exploit script at: {exploit_script}"
            self.log_history.append(log_message)
            logger.info(log_message)
            self._commit_changes()
            execute_message = self.execute(prev_agent_message)
            self._clean_untracked()
            self.log_history.clear()
            return execute_message
        else:
            log_message = f"No changes to exploit_files detected."
            self.log_history.append(log_message)
            logger.info(log_message)
            log_message = "\n".join(self.log_history)
            self.log_history.clear()
            logger.info(log_message)
            agent_message =  ExploitAgentMessage(agent_id=self.agent_id, message=f"{log_message}\nSkipping.", prev=prev_agent_message)        
            return agent_message

    def execute(self, prev_agent_message: Optional[AgentMessage] = None) -> Message:
        """Execute the exploit workflow."""
        restart_status = self.restart_resources()
        if restart_status is not None:
            return restart_status
        try:
            logger.info("Executing exploit.sh")
            exploit_output, exit_code = self.run_exploit()
            self.log_history.append(f"Execution exploit.sh Output: {exploit_output}\nExit code: {exit_code}")

            if exit_code == 0:
                copied_files_dir = self._store_exploit()
                if copied_files_dir:
                    logger.status(f"Exploit executed successfully. Files copied to {copied_files_dir}.", True)
                    log_message = "\n".join(self.log_history)
                    self._clean_untracked(cwd=self.task_dir / "tmp" / "codebase")
                    return ExploitAgentMessage(agent_id=self.agent_id, message=f"{log_message}\nExploit executed successfully.", success=True, exploit_files_dir=copied_files_dir, prev=prev_agent_message)
                else:
                    log_message = "Error copying over exploit files. Cannot proceed to patching."
                    logger.status(log_message)
                    self.log_history.append(log_message)
                    log_message = "\n".join(self.log_history)
                    return ExploitAgentMessage(agent_id=self.agent_id, message=f"{log_message}\nError copying exploit files.", prev=prev_agent_message)
            else:
                logger.status(f"Exploit failed with exit code {exit_code}. Output: {exploit_output}")
                self.log_history.append("Exploit failed.")
                exploit_log = "\n".join(self.log_history)
                return ExploitAgentMessage(agent_id=self.agent_id, message=exploit_log, prev=prev_agent_message)
        except Exception as e:
            log_message = f"Error during exploit execution: {str(e)}"
            logger.status(log_message)
            self.log_history.append(log_message)
            exploit_log = "\n".join(self.log_history)
            return ExploitAgentMessage(agent_id=self.agent_id, message=exploit_log, prev=prev_agent_message)

    def restart_setup_resources(self, prev_agent_message: Optional[AgentMessage] = None):
        bounty_resource, repo_resource = DefaultResource.BOUNTY_RESOURCE.get_resource(self), DefaultResource.REPO_RESOURCE.get(self)

        if bounty_resource is not None:
            bounty_resource_restarted = self._restart_resource(bounty_resource)
            if not bounty_resource_restarted:
                logger.error("The bounty resource must restart successfully but did not.")
                return ExploitAgentMessage(agent_id=self.agent_id, message="The bounty resource cannot restart after the changes.", prev=prev_agent_message)
        
        if repo_resource is not None:
            repo_resource_restarted = self._restart_resource(repo_resource)
            if not repo_resource_restarted:
                logger.error("The repo resource must restart successfully but did not.")
                return ExploitAgentMessage(agent_id=self.agent_id, message="The repo resource cannot restart after the changes.", prev=prev_agent_message)
        return None

    def _restart_resource(self, resource):
        """Restart a specific resource."""
        try:
            resource.restart()
            logger.info(f"{resource.resource_id} resource restarted successfully.")
            return True
        except Exception as e:
            logger.error(f"Failed to restart {resource.resource_id} resource: {e}")
        return False
    
    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
    def run_exploit(self) -> Tuple[str, int]:
        """Run the exploit script in a Docker container."""

        init_files = DefaultResource.INIT_FILES.get_resource(self)
        volumes = {
            os.path.abspath(init_files.tmp_dir): {"bind": f"/app", "mode": "rw"},
        }

        exploit_command = f"bash exploit.sh"
        try:
            docker_resource = DefaultResource.DOCKER.get_resource(self)
            exploit_result = docker_resource.execute(
                docker_image="cybench/bountyagent:latest",
                command=exploit_command,
                network="shared_net",
                volumes=volumes,
            )
            return exploit_result
        except docker.errors.ContainerError as e:
            logger.error(f"Container error during exploit: {str(e)}")
            return str(e), 1

    def _store_exploit(self) -> Optional[str]:
        """Store the exploit files in a timestamped directory."""
        try:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            new_exploit_dir = f"{self.exploits_dir}-{timestamp}"

            if self.tmp_exploits_dir.exists() and self.tmp_exploits_dir.is_dir():
                if any(self.tmp_exploits_dir.iterdir()):
                    shutil.copytree(str(self.tmp_exploits_dir), new_exploit_dir, ignore=shutil.ignore_patterns('codebase'))
                    logger.info(f"Exploits successfully moved to {new_exploit_dir}.")
                    return new_exploit_dir
                else:
                    logger.warning("Exploits directory is empty. No files to move.")
            else:
                logger.warning("No exploits directory found to move.")
        except Exception as e:
            logger.error(f"Failed to move exploits directory: {e}")

        return None

    def cleanup(self):
        """Clean up temporary files and directories."""
        try:
            if self.exploits_dir.exists():
                shutil.rmtree(self.exploits_dir)
                logger.info(f"Cleaned up temporary exploits directory: {self.exploits_dir}")
        except Exception as e:
            logger.info(f"Error during final cleanup: {e}")

    def to_dict(self) -> dict:
        """Serializes the ExploitAgent state to a dictionary."""
        return {
            'bounty_dir': str(self.bounty_dir),
            'exploits_dir': str(self.exploits_dir),
            'tmp_exploits_dir': str(self.tmp_exploits_dir),
            'agent_id': self.agent_id,
            'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S%z')
        }

    @classmethod
    def from_dict(cls, data: dict, **kwargs) -> 'ExploitAgent':
        """
        Creates an ExploitAgent instance from a serialized dictionary.
        """
        kwargs['bounty_dir'] = data['bounty_dir']
        agent = cls(**kwargs)
        agent.exploits_dir = Path(data['exploits_dir'])
        agent.tmp_exploits_dir = Path(data['tmp_exploits_dir'])
        agent.log_history = data['log_history']
        agent._agent_id = data['agent_id']
        return agent

    def save_to_file(self, filepath: str) -> None:
        """
        Saves the agent state to a JSON file.
        """
        import json
        state = self.to_dict()
        with open(filepath, 'w') as f:
            json.dump(state, f, indent=2)

    @classmethod
    def load_from_file(cls, filepath: str, **kwargs) -> 'ExploitAgent':
        """
        Loads an agent state from a JSON file.
        """
        import json
        with open(filepath, 'r') as f:
            data = json.load(f)
        return cls.from_dict(data, **kwargs)