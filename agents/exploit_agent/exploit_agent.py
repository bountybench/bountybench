import os
import shutil
import subprocess
import time
from typing import List, Optional, Tuple

import docker

from agents.base_agent import BaseAgent
from resources.docker_resource import DockerResource
from resources.kali_env_resource import KaliEnvResource
from resources.setup_resource import SetupResource
from responses.answer_response import AnswerResponse
from responses.command_response import CommandResponse
from responses.command_response_interface import CommandResponseInterface
from responses.response import Response
from utils.logger import get_main_logger
from responses.base_response import BaseResponse

logger = get_main_logger(__name__)

class ExploitAgent(BaseAgent):
    """
    ExploitAgent is responsible for managing and executing exploit scripts.
    
    This agent checks for the presence of an exploit.sh file, executes it,
    and verifies its success. It also handles the copying of exploit files,
    restarting of resources, and storing of exploit results.
    Attributes:
        REQUIRED_RESOURCES (List): List of required resources for this agent.
        OPTIONAL_RESOURCES (List[Tuple]): List of optional resources for this agent.
        ACCESSIBLE_RESOURCES (List[Union[Tuple, Type]]): List of accessible resources for this agent.
    """

    REQUIRED_RESOURCES = [KaliEnvResource, DockerResource]
    OPTIONAL_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource")]
    ACCESSIBLE_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource"), KaliEnvResource, DockerResource]

    def __init__(self, *args, **kwargs):
        """
        Initialize the ExploitAgent.
        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """

        super().__init__(*args, **kwargs)
        self.bounty_dir = kwargs.get('bounty_dir')
        self.exploits_dir_name = "exploits"
        self.exploits_dir = os.path.join(self.bounty_dir, self.exploits_dir_name)
        self.tmp_exploits_dir = "/tmp/exploit_files"  # Keep this path in the container
        
        self.log_history = []

        self.kali_env = self._get_resource(KaliEnvResource)

        
        # Create both local and container exploit directories
        logger.info(f"ExploitAgent initialized with:")
        logger.info(f"bounty_dir: {self.bounty_dir}")
        logger.info(f"exploits_dir: {self.exploits_dir}")
        logger.info(f"tmp_exploits_dir: {self.tmp_exploits_dir}")

    def run(self, responses: List[Response]) -> Response:
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        response = responses[0]
        
        if issubclass(response.__class__, CommandResponseInterface):
            # Look for exploit.sh in /tmp/exploit_files where it's being created
            exploit_script = os.path.join(self.tmp_exploits_dir, "exploit.sh")
            
            stdout, stderr = self.kali_env.run_command(f"[ -f {exploit_script} ] && echo 'exists'")
            
            if "exists" not in stdout:
                logger_message = f"No exploit.sh found in {exploit_script}"
                logger.info(logger_message)
                self.log_history.append(logger_message)
                return BaseResponse("\n".join(self.log_history))
            else:
                logger_message = f"exploit.sh detected in {exploit_script}, executing exploit..."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                execute_response = self.execute(response)
                return execute_response

    def execute(self, command_response: CommandResponse) -> Response:
        """Execute the exploit script and process the results."""
        logger.info("Starting execute method")
        
        # Debug: Check if files exist before copying
        self._copy_exploit_files()
        logger.info("Completed _copy_exploit_files")
        
        self.restart_resources()
        logger.info("Completed restart_resources")
        
        exploit_output, exit_code = self.run_exploit()
        logger.info(f"run_exploit completed with exit_code: {exit_code}, output: {exploit_output}")
        
        # Debug: Check exploit result files
        
        if exit_code == 0:
            logger.info("Exploit executed successfully.")
            copied_files_dir = self._store_exploit()
            if copied_files_dir:
                logger_message = f"Exploit files copied successfully to {copied_files_dir}. Ready for patching."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                return AnswerResponse("\n".join(self.log_history) + f"\nAnswer: {copied_files_dir}")
            else:
                error_message = "Error copying exploit files. Cannot proceed to patching."
                logger.error(error_message)
                self.log_history.append(error_message)
                return BaseResponse("\n".join(self.log_history))
        else:
            logger_message = f"Exploit failed with exit code {exit_code}. Output: {exploit_output}"
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return BaseResponse("\n".join(self.log_history))



    def run_exploit(self) -> Tuple[str, int]:
        """
        Run the exploit script in the KaliEnv container and return both the output and exit code.
        The exploit script's exit code determines success (0) or failure (1).
        Returns:
            Tuple[str, int]: A tuple containing the output and exit code of the exploit script.
        """
        try:
            # Run exploit and get its output
            stdout, stderr = self.kali_env.run_command("/tmp/exploit_files/exploit.sh")
            
            # Check exit code of last command
            exit_code_out, _ = self.kali_env.run_command("echo $?")
            exit_code = 0 if exit_code_out.strip() == "0" else 1
            
            return stdout, exit_code

        except Exception as e:
            logger.error(f"Error running exploit: {str(e)}")
            return str(e), -1


    def _copy_exploit_files(self):
        """Copy exploit files from container's /tmp/exploit_files to local exploits directory"""
        stdout, stderr = self.kali_env.run_command(f"ls -1 {self.tmp_exploits_dir}")
        if stderr:
            logger.error(f"Error listing files in Kali container: {stderr}")
            return

        files = stdout.strip().split('\n')
        if os.path.exists(self.exploits_dir):
            shutil.rmtree(self.exploits_dir)
        os.makedirs(self.exploits_dir, exist_ok=True)

        for file in files:
            if not file:  # Skip empty strings
                continue
                
            source_path = os.path.join(self.tmp_exploits_dir, file)
            dest_path = os.path.join(self.exploits_dir, file)
            
            copy_command = f"docker cp {self.kali_env.container.name}:{source_path} {dest_path}"
            
            try:
                subprocess.run(copy_command, shell=True, check=True)
                os.chmod(dest_path, 0o755)
                logger.info(f"Copied and made executable: {file}")
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to copy file {file}: {e}")

        logger_message = f"Copied all exploit files from Kali container to {self.exploits_dir}"
        logger.info(logger_message)
        self.log_history.append(logger_message)

    
    def restart_resources(self):
        """
        Restart the task server and repo resources if they exist.
        """
        self._restart_resource(self.task_server, "Task server")
        self._restart_resource(self.repo_resource, "Repo")

    def _restart_resource(self, resource, resource_name):
        """
        Restart a given resource and log the result.
        Args:
            resource: The resource to restart.
            resource_name (str): The name of the resource for logging purposes.
        """
        if resource:
            try:
                resource.restart()
                logger_message = f"{resource_name} resource restarted successfully."
                logger.info(logger_message)
                self.log_history.append(logger_message)
            except Exception as e:
                logger_message = f"Failed to restart {resource_name.lower()} resource: {e}"
                logger.error(logger_message)
                self.log_history.append(logger_message)


    def _store_exploit(self) -> Optional[str]:
        """
        Store the exploits folder in a timestamped directory.
        This method moves the exploits folder into a timestamped folder for future reference.
        The exploits folder acts as a staging area for active exploiting workflows.
        Returns:
            Optional[str]: The path to the new exploit directory if successful, None otherwise.
        """
        try:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            new_exploit_dir = f"{self.exploits_dir}-{timestamp}"

            if os.path.exists(self.exploits_dir) and os.path.isdir(self.exploits_dir):
                if os.listdir(self.exploits_dir):
                    shutil.move(self.exploits_dir, new_exploit_dir)
                    logger_message = f"Exploits successfully moved to {new_exploit_dir}."
                    logger.info(logger_message)
                    self.log_history.append(logger_message)
                    return new_exploit_dir
                else:
                    logger_message = "Exploits directory is empty. No files to move."
                    logger.warning(logger_message)
                    self.log_history.append(logger_message)
            else:
                logger_message = "No exploits directory found to move."
                logger.warning(logger_message)
                self.log_history.append(logger_message)

        except Exception as e:
            logger_message = f"Failed to move exploits directory: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)

        return None

    def cleanup(self):
        """
        Perform final cleanup operations.
        This method is intended to be called when the agent is being destroyed or the process is ending.
        """
        try:
            if os.path.exists(self.exploits_dir):
                shutil.rmtree(self.exploits_dir)
                logger_message = f"Cleaned up temporary exploits directory: {self.exploits_dir}"
                logger.info(logger_message)
                self.log_history.append(logger_message)
        except Exception as e:
            logger_message = f"Error during final cleanup: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)