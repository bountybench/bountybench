import os
import shutil
import subprocess
import time
from typing import List, Optional, Tuple

import docker

from agents.base_agent import BaseAgent
from resources.docker_resource import DockerResource
from resources.init_files_resource import InitFilesResource
from resources.kali_env_resource import KaliEnvResource
from resources.setup_resource import SetupResource
from responses.answer_response import AnswerResponse
from responses.command_response import CommandResponse
from responses.command_response_interface import CommandResponseInterface
from responses.observation import Observation
from responses.response import Response
from utils.logger import get_main_logger
from responses.base_response import BaseResponse

logger = get_main_logger(__name__)

class ExploitAgent(BaseAgent):
    """
    ExploitAgent is responsible for managing and executing exploit scripts.
    
    This agent checks for the presence of an exploit.sh file, executes it,
    and verifies its success. It also handles the copying of exploit files,
    restarting of resources, and storing of exploit results.
    """

    REQUIRED_RESOURCES = [InitFilesResource, KaliEnvResource, DockerResource]
    OPTIONAL_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource")]
    ACCESSIBLE_RESOURCES = [(SetupResource, "task_server"), (SetupResource, "repo_resource"), InitFilesResource, KaliEnvResource, DockerResource]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bounty_dir = kwargs.get('bounty_dir')
        self.exploits_dir_name = "exploits"
        self.exploits_dir = os.path.join(self.bounty_dir, self.exploits_dir_name)
        
        self.tmp_exploits_dir = "/tmp/exploit_files"

        self.log_history = []

        self.task_server = self._get_resource(SetupResource, "task_server")
        self.repo_resource = self._get_resource(SetupResource, "repo_resource")
        self.docker = self._get_resource(DockerResource)

        os.makedirs(self.exploits_dir, exist_ok=True)

    def run(self, responses: List[Response]) -> Response:
        if len(responses) != 1:
            raise ValueError(f"Accepts only a single response, but received {len(responses)} responses")
        response = responses[0]
        if not issubclass(response.__class__, CommandResponseInterface):
            raise TypeError(f"Response not of an interpretable type. The response type is {response.__class__} but we expect a class of CommandResponseInterface")

        exploit_script = f"{self.tmp_exploits_dir}/exploit.sh"
        logger.info(f"Checking for exploit script at: {exploit_script}")

        stdout, stderr = self.kali_env.run_command(f"ls -la {os.path.dirname(exploit_script)}")
        logger.info(f"Contents of {os.path.dirname(exploit_script)}:\n{stdout}")
        if stderr:
            logger.error(f"Error listing directory: {stderr}")

        stdout, stderr = self.kali_env.run_command(f"[ -f {exploit_script} ] && echo 'exists'")
        logger.info(f"Exploit script check result: {stdout.strip()}")

        if "exists" in stdout:
            logger.info(f"Found exploit script at: {exploit_script}")
            
            stdout, stderr = self.kali_env.run_command(f"cat {exploit_script}")
            logger.info(f"Exploit script contents:\n{stdout}")
            if stderr:
                logger.error(f"Error reading exploit script: {stderr}")

            logger_message = f"exploit.sh detected at {exploit_script}, executing exploit..."
            logger.info(logger_message)
            self.log_history.append(logger_message)
            execute_response = self.execute(response)
            return execute_response
        else:
            logger_message = f"No exploit.sh found at {exploit_script}."
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return BaseResponse("\n".join(self.log_history))

    def execute(self, command_response: CommandResponse) -> Response:
        self._copy_exploit_files()
        self.restart_resources()
        exploit_output, exit_code = self.run_exploit()

        if exit_code == 0:
            logger_message = "Exploit executed successfully." 
            copied_files_dir = self._store_exploit()
            if copied_files_dir:
                logger_message += f" Exploit files copied successfully to {copied_files_dir}. Ready for patching."
                logger.info(logger_message)
                self.log_history.append(logger_message)
                command_response.set_observation(
                    Observation("Exploit executed successfully. Ready for patching.")
                )
                return AnswerResponse("\n".join(self.log_history) + f"\nAnswer: {copied_files_dir}")
            else:
                error_message = "Error copying over exploit files. Cannot proceed to patching."
                logger.error(error_message)
                self.log_history.append(error_message)
                raise Exception(error_message)
        else:
            logger_message = f"Exploit failed with exit code {exit_code}. Output: {exploit_output}"
            logger.info(logger_message)
            self.log_history.append(logger_message)
            return BaseResponse("\n".join(self.log_history))

    def _copy_exploit_files(self):
        stdout, stderr = self.kali_env.run_command(f"ls -1 {self.tmp_exploits_dir}")
        if stderr:
            logger.error(f"Error listing files in Kali container: {stderr}")
            return

        files = stdout.strip().split('\n')

        if os.path.exists(self.exploits_dir):
            shutil.rmtree(self.exploits_dir)
        os.makedirs(self.exploits_dir, exist_ok=True)

        for file in files:
            source_path = os.path.join(self.tmp_exploits_dir, file)
            dest_path = os.path.join(self.exploits_dir, file)
            
            copy_command = f"docker cp {self.kali_env.container.name}:{source_path} {dest_path}"
            
            try:
                subprocess.run(copy_command, shell=True, check=True)
                os.chmod(dest_path, 0o755)
                logger.info(f"Copied and made executable: {file}")
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to copy file {file}: {e}")

        logger_message = f"Copied all exploit files from Kali container to {self.exploits_dir}"
        logger.info(logger_message)
        self.log_history.append(logger_message)

    def restart_resources(self):
        self._restart_resource(self.task_server, "Task server")
        self._restart_resource(self.repo_resource, "Repo")

    def _restart_resource(self, resource, resource_name):
        if resource:
            try:
                resource.restart()
                logger_message = f"{resource_name} resource restarted successfully."
                logger.info(logger_message)
                self.log_history.append(logger_message)
            except Exception as e:
                logger_message = f"Failed to restart {resource_name.lower()} resource: {e}"
                logger.error(logger_message)
                self.log_history.append(logger_message)

    def run_exploit(self) -> Tuple[str, int]:
        volumes = {
            os.path.join(self.init_files.task_repo_dir, 'codebase'): {"bind": "/app/codebase", "mode": "rw"},
            os.path.join(self.bounty_dir, 'setup_files'): {"bind": "app/setup_files", "mode": "rw"},
            "/tmp": {"bind": "/tmp", "mode": "rw"}
        }

        # Command to navigate to the codebase and run requirements.sh
        setup_command = "bash /app/setup_files/requirements.sh"
        
        # Command to execute the exploit script
        exploit_command = "bash /tmp/exploit_files/exploit.sh"

        try:
            # Run the setup command first
            setup_result = self.docker.execute(
                docker_image="cybench/cybounty:latest",
                command=setup_command,
                network="shared_net",
                work_dir=None,
                volumes=volumes,
            )
            setup_output, setup_exit_code = setup_result
            if setup_exit_code != 0:
                return f"Setup failed:\n{setup_output}", setup_exit_code
            
            # Run the exploit command
            exploit_result = self.docker.execute(
                docker_image="cybench/cybounty:latest",
                command=exploit_command,
                network="shared_net",
                work_dir=None,
                volumes=volumes,
            )
            output, exit_code = exploit_result
            return output, exit_code
        except docker.errors.ContainerError as e:
            return str(e), 1

    def verify_exploit(self, exploit_result: Tuple[str, int]) -> bool:
        output, exit_code = exploit_result

        logger_message = f"Exploit output:\n{output}"
        logger.info(logger_message)
        self.log_history.append(logger_message)

        logger_message = f"Exploit exit code: {exit_code}"
        logger.info(logger_message)
        self.log_history.append(logger_message)

        return exit_code == 0 

    def _store_exploit(self) -> Optional[str]:
        try:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            new_exploit_dir = f"{self.exploits_dir}-{timestamp}"

            if os.path.exists(self.exploits_dir) and os.path.isdir(self.exploits_dir):
                if os.listdir(self.exploits_dir):
                    shutil.move(self.exploits_dir, new_exploit_dir)
                    logger_message = f"Exploits successfully moved to {new_exploit_dir}."
                    logger.info(logger_message)
                    self.log_history.append(logger_message)
                    return new_exploit_dir
                else:
                    logger_message = "Exploits directory is empty. No files to move."
                    logger.warning(logger_message)
                    self.log_history.append(logger_message)
            else:
                logger_message = "No exploits directory found to move."
                logger.warning(logger_message)
                self.log_history.append(logger_message)

        except Exception as e:
            logger_message = f"Failed to move exploits directory: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)

        return None

    def cleanup(self):
        try:
            if os.path.exists(self.exploits_dir):
                shutil.rmtree(self.exploits_dir)
                logger_message = f"Cleaned up temporary exploits directory: {self.exploits_dir}"
                logger.info(logger_message)
                self.log_history.append(logger_message)
        except Exception as e:
            logger_message = f"Error during final cleanup: {e}"
            logger.error(logger_message)
            self.log_history.append(logger_message)