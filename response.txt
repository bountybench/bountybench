I guess the question is what defines a workflow. For instance, we define an agent as a class that takes in an InputReponse: str and outputs an OutputResonse: str, where Response objects are generic to the agent.

What does a Phase of a workflow consist of? And how do they chain?

I suppose the Workflow consists of: Logging + ResourceConstraints + 1 or more Phases

Then a Phase consists of one or more Agents ...



The challenges you’re facing point to the need for a more structured design that introduces clear phases, simplifies the abstraction layers, and enforces rules at compile/run time. When dealing with complex workflows, it’s often beneficial to formalize steps around phases, interactions, and iterations with stricter boundaries and validation. Here are some suggestions to address the points you raised:

1. ▪️ Introducing Phases: 
   • Define an Enum or class to represent workflow phases (e.g., EXPLOIT, PATCH), and include a phase field at the iteration or workflow level. 
   • A WorkflowIteration might belong to a particular phase, so you can separate logic and validation for different parts of the process. 
   • Optionally, create separate subclasses or strategy patterns for phase-specific behaviors. This step enforces differences in handling “exploit” vs “patch”, making phases explicit.

2. ▪️ Simplifying Iterations vs. Interactions:
   • If each iteration logically contains only one interaction per agent, consider flattening the structure: remove one of the levels or rename concepts so that each step is intuitive (e.g., a Phase contains a sequence of AgentInteractions rather than nested iterations).
   • Alternatively, if you want to keep both, document clearly what an iteration vs. an interaction represents. Perhaps an iteration is a complete cycle across all agents, while an interaction is the exchange with a single agent. 
   • Simplify by introducing a “Step” abstraction if that reduces confusion, where a step corresponds to a single agent interaction, and a phase groups a series of steps.

3. ▪️ Introducing a Workflow Class/Primitive:
   • Create an abstract base class, e.g. BaseWorkflow, that defines required methods: initialize(), run_phase(), log_interaction(), finalize(), etc.
   • This class can enforce logging requirements by raising errors if expected logs or metadata aren’t properly recorded, using checks at critical points in the workflow. 
   • For static typing benefits, use mypy or similar tools along with Python’s type hints to catch mistakes when implementing specific workflows. 
   • Example approach: 

class BaseWorkflow:
    phase: PhaseEnum
    metadata: WorkflowMetadata
    log: WorkflowLog

    def __init__(self, metadata: WorkflowMetadata):
        self.metadata = metadata
        self.log = WorkflowLog(metadata=metadata, iterations=[])
        self.phase = PhaseEnum.INITIAL

    def run(self):
        # enforce structure: iterate phases, record start/stop times, validate logging
        raise NotImplementedError("Must implement run() in subclass") 

    def log_interaction(self, interaction: AgentInteraction):
        # enforce required fields present, enforce correct updates to self.log
        if not interaction.metadata:
            raise ValueError("Missing metadata in interaction")
        # append to current iteration or create new one based on phase/iteration logic
        
        # Add additional checks as needed

   • Subclasses of BaseWorkflow implement run() with specific logic for phases, using type-checked inputs/outputs and ensuring proper logging at each step. If they miss required logging, the base class can throw an exception.

4. ▪️ Additional Strategies: 
   • Use dataclass validation libraries or post-init methods to assert required fields aren’t missing.
   • Make use of Python’s Abstract Base Classes (ABCs) to force subclasses to implement critical methods.
   • Clearly document the invariant: For example, “every interaction must be logged with start_time and end_time, at least one action must be recorded” and enforce that in base methods.
   • Use type hints and mypy in CI/CD pipelines to catch incorrect workflows before deployment.

By introducing a layered design with explicit phases and a base workflow class, you can create a robust system where incorrect workflows fail fast due to missing logs or incorrect structure. This structured approach minimizes runtime surprises and leverages static typing to catch errors early.
